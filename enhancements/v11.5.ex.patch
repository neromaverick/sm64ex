diff --git a/Makefile b/Makefile
index 772f31a..cfb0652 100644
--- a/Makefile
+++ b/Makefile
@@ -746,4 +746,7 @@ $(BUILD_DIR)/include/text_strings.h: include/text_strings.h.in
 	$(TEXTCONV) charmap.txt $< $@
 
+$(BUILD_DIR)/include/text_cheats_strings.h: include/text_cheats_strings.h.in
+	$(TEXTCONV) charmap.txt $< $@
+
 $(BUILD_DIR)/include/text_menu_strings.h: include/text_menu_strings.h.in
 	$(TEXTCONV) charmap_menu.txt $< $@
@@ -789,4 +792,5 @@ ALL_DIRS := $(BUILD_DIR) $(addprefix $(BUILD_DIR)/,$(SRC_DIRS) $(ASM_DIRS) $(GOD
 DUMMY != mkdir -p $(ALL_DIRS)
 
+$(BUILD_DIR)/include/text_strings.h: $(BUILD_DIR)/include/text_cheats_strings.h
 $(BUILD_DIR)/include/text_strings.h: $(BUILD_DIR)/include/text_menu_strings.h
 $(BUILD_DIR)/include/text_strings.h: $(BUILD_DIR)/include/text_options_strings.h
diff --git a/dynos/cheater_menu.txt b/dynos/cheater_menu.txt
new file mode 100644
index 0000000..c186acc
--- /dev/null
+++ b/dynos/cheater_menu.txt
@@ -0,0 +1,34 @@
+# Dynamic Options System aka DynOS v0.4
+# By PeachyPeach
+#
+# This is a comment
+# Here are the available commands:
+# SUBMENU [Name] [Label] [Label2]
+# TOGGLE  [Name] [Label] [ConfigName] [InitialValue]
+# SCROLL  [Name] [Label] [ConfigName] [InitialValue] [Min] [Max] [Step]
+# CHOICE  [Name] [Label] [ConfigName] [InitialValue] [ChoiceStrings...]
+# BIND    [Name] [Label] [ConfigName] [Mask] [DefaultValues]
+# BUTTON  [Name] [Label] [FuncName]
+# ENDMENU
+#
+# Valid Label characters:
+# 0-9 A-Z a-z
+# '.,-()&:!%?"~_
+#
+
+
+SUBMENU "cheater_submenu" "CHEATER" "CHEATER"
+	TOGGLE	"chaos_mode"	"CHAOS MODE"			"chaos_mode"	0
+	BIND	"time_button"	"Time Stop Button"		"time_button"	0x0080	0x0008 0x1001 0xFFFF
+	SUBMENU "che_submenu" "New Cheats!" "CHEATER"
+		TOGGLE	"no_heavy"	"No Hold Heavy"			"no_heavy"		0
+		TOGGLE	"swim_any"	"Swim Anywhere"			"swim_any"		0
+		TOGGLE	"haz_walk"	"Walk On Hazards"		"haz_walk"		0
+		TOGGLE	"coin_mag"	"Coin Magnet"			"coin_mag"		0
+		SCROLL	"spl"		"Spamba Per Level"		"spl"			0 0 7 1
+	ENDMENU
+	SUBMENU "wat_submenu" "Drain JRB?" "CHEATER"
+		TOGGLE	"wat_con"	"Water Control"			"wat_con"		0
+		SCROLL	"wat_lev"	"Water Level (9)"		"wat_lev"		0 1 20 1
+	ENDMENU
+ENDMENU
diff --git a/include/libc/time.h b/include/libc/time.h
new file mode 100644
index 0000000..907fcbe
--- /dev/null
+++ b/include/libc/time.h
@@ -0,0 +1,234 @@
+/* Copyright (C) 1991-2017 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+/*
+ *        ISO C99 Standard: 7.23 Date and time        <time.h>
+ */
+#ifndef        _TIME_H
+#define _TIME_H        1
+#include <features.h>
+#define __need_size_t
+#define __need_NULL
+#include <stddef.h>
+/* This defines CLOCKS_PER_SEC, which is the number of processor clock
+   ticks per second, and possibly a number of other constants.   */
+#include <bits/time.h>
+/* Many of the typedefs and structs whose official home is this header
+   may also need to be defined by other headers.  */
+#include <bits/types/clock_t.h>
+#include <bits/types/time_t.h>
+#include <bits/types/struct_tm.h>
+#if defined __USE_POSIX199309 || defined __USE_ISOC11
+# include <bits/types/struct_timespec.h>
+#endif
+#ifdef __USE_POSIX199309
+# include <bits/types/clockid_t.h>
+# include <bits/types/timer_t.h>
+# include <bits/types/struct_itimerspec.h>
+struct sigevent;
+#endif
+#ifdef __USE_XOPEN2K
+# ifndef __pid_t_defined
+typedef __pid_t pid_t;
+#  define __pid_t_defined
+# endif
+#endif
+#ifdef __USE_XOPEN2K8
+# include <bits/types/locale_t.h>
+#endif
+#ifdef __USE_ISOC11
+/* Time base values for timespec_get.  */
+# define TIME_UTC 1
+#endif
+__BEGIN_DECLS
+/* Time used by the program so far (user time + system time).
+   The result / CLOCKS_PER_SECOND is program time in seconds.  */
+extern clock_t clock (void) __THROW;
+/* Return the current time and put it in *TIMER if TIMER is not NULL.  */
+extern time_t time (time_t *__timer) __THROW;
+/* Return the difference between TIME1 and TIME0.  */
+extern double difftime (time_t __time1, time_t __time0)
+     __THROW __attribute__ ((__const__));
+/* Return the `time_t' representation of TP and normalize TP.  */
+extern time_t mktime (struct tm *__tp) __THROW;
+/* Format TP into S according to FORMAT.
+   Write no more than MAXSIZE characters and return the number
+   of characters written, or 0 if it would exceed MAXSIZE.  */
+extern size_t strftime (char *__restrict __s, size_t __maxsize,
+                        const char *__restrict __format,
+                        const struct tm *__restrict __tp) __THROW;
+#ifdef __USE_XOPEN
+/* Parse S according to FORMAT and store binary time information in TP.
+   The return value is a pointer to the first unparsed character in S.  */
+extern char *strptime (const char *__restrict __s,
+                       const char *__restrict __fmt, struct tm *__tp)
+     __THROW;
+#endif
+#ifdef __USE_XOPEN2K8
+/* Similar to the two functions above but take the information from
+   the provided locale and not the global locale.  */
+extern size_t strftime_l (char *__restrict __s, size_t __maxsize,
+                          const char *__restrict __format,
+                          const struct tm *__restrict __tp,
+                          locale_t __loc) __THROW;
+#endif
+#ifdef __USE_GNU
+extern char *strptime_l (const char *__restrict __s,
+                         const char *__restrict __fmt, struct tm *__tp,
+                         locale_t __loc) __THROW;
+#endif
+/* Return the `struct tm' representation of *TIMER
+   in Universal Coordinated Time (aka Greenwich Mean Time).  */
+extern struct tm *gmtime (const time_t *__timer) __THROW;
+/* Return the `struct tm' representation
+   of *TIMER in the local timezone.  */
+extern struct tm *localtime (const time_t *__timer) __THROW;
+#ifdef __USE_POSIX
+/* Return the `struct tm' representation of *TIMER in UTC,
+   using *TP to store the result.  */
+extern struct tm *gmtime_r (const time_t *__restrict __timer,
+                            struct tm *__restrict __tp) __THROW;
+/* Return the `struct tm' representation of *TIMER in local time,
+   using *TP to store the result.  */
+extern struct tm *localtime_r (const time_t *__restrict __timer,
+                               struct tm *__restrict __tp) __THROW;
+#endif        /* POSIX */
+/* Return a string of the form "Day Mon dd hh:mm:ss yyyy\n"
+   that is the representation of TP in this format.  */
+extern char *asctime (const struct tm *__tp) __THROW;
+/* Equivalent to `asctime (localtime (timer))'.  */
+extern char *ctime (const time_t *__timer) __THROW;
+#ifdef __USE_POSIX
+/* Reentrant versions of the above functions.  */
+/* Return in BUF a string of the form "Day Mon dd hh:mm:ss yyyy\n"
+   that is the representation of TP in this format.  */
+extern char *asctime_r (const struct tm *__restrict __tp,
+                        char *__restrict __buf) __THROW;
+/* Equivalent to `asctime_r (localtime_r (timer, *TMP*), buf)'.  */
+extern char *ctime_r (const time_t *__restrict __timer,
+                      char *__restrict __buf) __THROW;
+#endif        /* POSIX */
+/* Defined in localtime.c.  */
+extern char *__tzname[2];        /* Current timezone names.  */
+extern int __daylight;                /* If daylight-saving time is ever in use.  */
+extern long int __timezone;        /* Seconds west of UTC.  */
+#ifdef        __USE_POSIX
+/* Same as above.  */
+extern char *tzname[2];
+/* Set time conversion information from the TZ environment variable.
+   If TZ is not defined, a locale-dependent default is used.  */
+extern void tzset (void) __THROW;
+#endif
+#if defined __USE_MISC || defined __USE_XOPEN
+extern int daylight;
+extern long int timezone;
+#endif
+#ifdef __USE_MISC
+/* Set the system time to *WHEN.
+   This call is restricted to the superuser.  */
+extern int stime (const time_t *__when) __THROW;
+#endif
+/* Nonzero if YEAR is a leap year (every 4 years,
+   except every 100th isn't, and every 400th is).  */
+#define __isleap(year)        \
+  ((year) % 4 == 0 && ((year) % 100 != 0 || (year) % 400 == 0))
+#ifdef __USE_MISC
+/* Miscellaneous functions many Unices inherited from the public domain
+   localtime package.  These are included only for compatibility.  */
+/* Like `mktime', but for TP represents Universal Time, not local time.  */
+extern time_t timegm (struct tm *__tp) __THROW;
+/* Another name for `mktime'.  */
+extern time_t timelocal (struct tm *__tp) __THROW;
+/* Return the number of days in YEAR.  */
+extern int dysize (int __year) __THROW  __attribute__ ((__const__));
+#endif
+#ifdef __USE_POSIX199309
+/* Pause execution for a number of nanoseconds.
+   This function is a cancellation point and therefore not marked with
+   __THROW.  */
+extern int nanosleep (const struct timespec *__requested_time,
+                      struct timespec *__remaining);
+/* Get resolution of clock CLOCK_ID.  */
+extern int clock_getres (clockid_t __clock_id, struct timespec *__res) __THROW;
+/* Get current value of clock CLOCK_ID and store it in TP.  */
+extern int clock_gettime (clockid_t __clock_id, struct timespec *__tp) __THROW;
+/* Set clock CLOCK_ID to value TP.  */
+extern int clock_settime (clockid_t __clock_id, const struct timespec *__tp)
+     __THROW;
+# ifdef __USE_XOPEN2K
+/* High-resolution sleep with the specified clock.
+   This function is a cancellation point and therefore not marked with
+   __THROW.  */
+extern int clock_nanosleep (clockid_t __clock_id, int __flags,
+                            const struct timespec *__req,
+                            struct timespec *__rem);
+/* Return clock ID for CPU-time clock.  */
+extern int clock_getcpuclockid (pid_t __pid, clockid_t *__clock_id) __THROW;
+# endif
+/* Create new per-process timer using CLOCK_ID.  */
+extern int timer_create (clockid_t __clock_id,
+                         struct sigevent *__restrict __evp,
+                         timer_t *__restrict __timerid) __THROW;
+/* Delete timer TIMERID.  */
+extern int timer_delete (timer_t __timerid) __THROW;
+/* Set timer TIMERID to VALUE, returning old value in OVALUE.  */
+extern int timer_settime (timer_t __timerid, int __flags,
+                          const struct itimerspec *__restrict __value,
+                          struct itimerspec *__restrict __ovalue) __THROW;
+/* Get current value of timer TIMERID and store it in VALUE.  */
+extern int timer_gettime (timer_t __timerid, struct itimerspec *__value)
+     __THROW;
+/* Get expiration overrun for timer TIMERID.  */
+extern int timer_getoverrun (timer_t __timerid) __THROW;
+#endif
+#ifdef __USE_ISOC11
+/* Set TS to calendar time based in time base BASE.  */
+extern int timespec_get (struct timespec *__ts, int __base)
+     __THROW __nonnull ((1));
+#endif
+#ifdef __USE_XOPEN_EXTENDED
+/* Set to one of the following values to indicate an error.
+     1  the DATEMSK environment variable is null or undefined,
+     2  the template file cannot be opened for reading,
+     3  failed to get file status information,
+     4  the template file is not a regular file,
+     5  an error is encountered while reading the template file,
+     6  memory allication failed (not enough memory available),
+     7  there is no line in the template that matches the input,
+     8  invalid input specification Example: February 31 or a time is
+        specified that can not be represented in a time_t (representing
+        the time in seconds since 00:00:00 UTC, January 1, 1970) */
+extern int getdate_err;
+/* Parse the given string as a date specification and return a value
+   representing the value.  The templates from the file identified by
+   the environment variable DATEMSK are used.  In case of an error
+   `getdate_err' is set.
+   This function is a possible cancellation point and therefore not
+   marked with __THROW.  */
+extern struct tm *getdate (const char *__string);
+#endif
+#ifdef __USE_GNU
+/* Since `getdate' is not reentrant because of the use of `getdate_err'
+   and the static buffer to return the result in, we provide a thread-safe
+   variant.  The functionality is the same.  The result is returned in
+   the buffer pointed to by RESBUFP and in case of an error the return
+   value is != 0 with the same values as given above for `getdate_err'.
+   This function is not part of POSIX and therefore no official
+   cancellation point.  But due to similarity with an POSIX interface
+   or due to the implementation it is a cancellation point and
+   therefore not marked with __THROW.  */
+extern int getdate_r (const char *__restrict __string,
+                      struct tm *__restrict __resbufp);
+#endif
+__END_DECLS
+#endif /* time.h.  */
\ No newline at end of file
diff --git a/include/text_cheats_strings.h.in b/include/text_cheats_strings.h.in
new file mode 100644
index 0000000..e32067d
--- /dev/null
+++ b/include/text_cheats_strings.h.in
@@ -0,0 +1,220 @@
+﻿#ifndef TEXT_CHEATS_STRINGS_H
+#define TEXT_CHEATS_STRINGS_H
+
+#if defined(VERSION_JP) || defined(VERSION_SH)
+
+#define TEXT_OPT_COIN      _("COIN CHEATS (HOLD B)")
+#define TEXT_OPT_HOVER     _("HOVER MODE")
+#define TEXT_OPT_MOON      _("MOON GRAVITY")
+#define TEXT_OPT_RUN       _("RUN SPEED")
+#define TEXT_OPT_NDB       _("NO DEATH BARRIER")
+#define TEXT_OPT_JUMP      _("ALL JUMPS HIGHER")
+#define TEXT_OPT_SPDDPS    _("SPEED DISPLAY")
+#define TEXT_OPT_TPF       _("T POSE FLOAT")
+#define TEXT_OPT_JB       _("SONG LIST")
+#define TEXT_OPT_JBC      _("PLAY SONG")
+#define TEXT_OPT_QUIKEND   _("QUICK ENDING")
+#define TEXT_OPT_HURT      _("HURT MARIO")
+#define TEXT_OPT_CANN      _("CANNON ANYWHERE")
+#define TEXT_OPT_AWK       _("AUTOWALLKICK")
+#define TEXT_OPT_SHELL     _("GET SHELL")
+#define TEXT_OPT_BOB       _("GET BOBOMB")
+#define TEXT_OPT_SPAMBA    _("SPAMBA")
+#define TEXT_OPT_SWIM       _("QUICK SWIM")
+#define TEXT_OPT_WING_CAP    _("GET WING CAP")
+#define TEXT_OPT_METAL_CAP    _("GET METAL CAP")
+#define TEXT_OPT_VANISH_CAP    _("GET VANISH CAP")
+#define TEXT_OPT_REMOVE_CAP    _("REMOVE CAP")
+#define TEXT_OPT_NORMAL_CAP    _("RESET CAP")
+#define TEXT_OPT_BLJ   _("BLJ ANYWHERE")
+#define TEXT_OPT_PAC   _("PLAY AS")
+#define TEXT_OPT_TRIPLE _("ALL JUMPS TRIPLE")
+#define TEXT_OPT_FLY _("FLYER")
+#define TEXT_OPT_NOB _("NO BOUNDS")
+#define TEXT_OPT_FLJ _("FORWARD LONG JUMP")
+#define TEXT_OPT_TS _("TIME STOP")
+
+#define TEXT_OPT_COIN1 _("OFF")
+#define TEXT_OPT_COIN2 _("COIN")
+#define TEXT_OPT_COIN3 _("BLUE COIN")
+#define TEXT_OPT_COIN4 _("RED COIN")
+
+#define TEXT_OPT_SS1   _("NORMAL")
+#define TEXT_OPT_SS2   _("SLOW")
+#define TEXT_OPT_SS3   _("SLOWER")
+#define TEXT_OPT_SS4   _("FAST")
+#define TEXT_OPT_SS5   _("FASTER")
+
+#define TEXT_OPT_PA1    _("DISABLED")
+#define TEXT_OPT_PA2    _("BLACK BOBOMB")
+#define TEXT_OPT_PA3    _("PINK BOBOMB")
+#define TEXT_OPT_PA4    _("GOOMBA")
+#define TEXT_OPT_PA5    _("KAPPA SHELL")
+#define TEXT_OPT_PA6    _("CHUCKYA")
+#define TEXT_OPT_PA7    _("FLYGUY")
+#define TEXT_OPT_PA8    _("PER LEVEL")
+
+#define TEXT_OPT_SEQ1    _("INTRO")
+#define TEXT_OPT_SEQ2    _("GRASS")
+#define TEXT_OPT_SEQ3    _("CASTLE")
+#define TEXT_OPT_SEQ4    _("WATER")
+#define TEXT_OPT_SEQ5    _("HOT")
+#define TEXT_OPT_SEQ6    _("BOWSER")
+#define TEXT_OPT_SEQ7    _("SNOW")
+#define TEXT_OPT_SEQ8    _("SLIDE")
+#define TEXT_OPT_SEQ9    _("SPOOKY")
+#define TEXT_OPT_SEQ10   _("UNDERGROUND")
+#define TEXT_OPT_SEQ11   _("KOOPA ROAD")
+#define TEXT_OPT_SEQ12   _("FINAL BOWSER")
+#define TEXT_OPT_SEQ13   _("TITLE")
+#define TEXT_OPT_SEQ14   _("FILE SELECT")
+#define TEXT_OPT_SEQ15   _("POWERUP")
+#define TEXT_OPT_SEQ16   _("METAL CAP")
+#define TEXT_OPT_SEQ17   _("BOSS")
+#define TEXT_OPT_SEQ18   _("MERRYGOROUND")
+#define TEXT_OPT_SEQ19   _("CREDITS")
+
+#define TEXT_OPT_HURTCHT1  _("DISABLED")
+#define TEXT_OPT_HURTCHT2  _("BURN")
+#define TEXT_OPT_HURTCHT3  _("SHOCK")
+#define TEXT_OPT_HURTCHT4  _("ONE HP")
+
+#define TEXT_OPT_SPAMCHT1  _("DISABLED")
+#define TEXT_OPT_SPAMCHT2  _("AMP")
+#define TEXT_OPT_SPAMCHT3  _("BLUE COIN SWITCH")
+#define TEXT_OPT_SPAMCHT4  _("BOWLING BALL")
+#define TEXT_OPT_SPAMCHT5  _("BREAKABLE BOX")
+#define TEXT_OPT_SPAMCHT6  _("BREAKABLE BOX SMALL")
+#define TEXT_OPT_SPAMCHT7  _("JUMPING BOX")
+#define TEXT_OPT_SPAMCHT8  _("CHECKERBOARD PLATFORM")
+#define TEXT_OPT_SPAMCHT9  _("CHUCKYA")
+#define TEXT_OPT_SPAMCHT10 _("FLYGUY")
+#define TEXT_OPT_SPAMCHT11 _("GOOMBAS")
+#define TEXT_OPT_SPAMCHT12 _("HEART")
+#define TEXT_OPT_SPAMCHT13 _("METAL BOX")
+#define TEXT_OPT_SPAMCHT14 _("PURPLE SWITCH")
+
+#define TEXT_OPT_BLJCHT1  _("DISABLED")
+#define TEXT_OPT_BLJCHT2  _("ENABLED")
+#define TEXT_OPT_BLJCHT3  _("ENABLED - BOOST: 1")
+#define TEXT_OPT_BLJCHT4  _("ENABLED - BOOST: 2")
+#define TEXT_OPT_BLJCHT5  _("ENABLED - BOOST: 3")
+#define TEXT_OPT_BLJCHT6  _("ENABLED - BOOST: 4")
+#define TEXT_OPT_BLJCHT7  _("ENABLED - BOOST: 5")
+#define TEXT_OPT_BLJCHT8  _("RAPID FIRE")
+#define TEXT_OPT_BLJCHT9  _("RAPID FIRE - BOOST: 1")
+#define TEXT_OPT_BLJCHT10 _("RAPID FIRE - BOOST: 2")
+#define TEXT_OPT_BLJCHT11 _("RAPID FIRE - BOOST: 3")
+#define TEXT_OPT_BLJCHT12 _("RAPID FIRE - BOOST: 4")
+#define TEXT_OPT_BLJCHT13 _("RAPID FIRE - BOOST: 5")
+
+#else // VERSION
+
+#define TEXT_OPT_COIN      _("Coin Cheats Hold [B]")
+#define TEXT_OPT_HOVER     _("Hover Mode")
+#define TEXT_OPT_MOON      _("Moon Gravity")
+#define TEXT_OPT_RUN       _("Run Speed Modifier")
+#define TEXT_OPT_NDB       _("No Death Barrier")
+#define TEXT_OPT_JUMP      _("All Jumps Higher")
+#define TEXT_OPT_SPDDPS    _("Speed Display")
+#define TEXT_OPT_TPF       _("T Pose Float [A]")
+#define TEXT_OPT_JB       _("Jukebox List")
+#define TEXT_OPT_JBC      _("Jukebox Activate")
+#define TEXT_OPT_QUIKEND   _("Quick Ending")
+#define TEXT_OPT_HURT      _("Hurt Mario Ｌ & [A]")
+#define TEXT_OPT_CANN      _("Cannon Anywhere Ｌ & [C]^")
+#define TEXT_OPT_AWK       _("AutoWallKick")
+#define TEXT_OPT_SHELL     _("Get Shell Ｌ & [R]")
+#define TEXT_OPT_BOB       _("Get Bobomb Ｌ & [B]")
+#define TEXT_OPT_SPAMBA    _("Spamba Ｌ & [Z]")
+#define TEXT_OPT_SWIM      _("Swift Swim")
+#define TEXT_OPT_WING_CAP  _("Get WING Cap")
+#define TEXT_OPT_METAL_CAP _("Get METAL Cap")
+#define TEXT_OPT_VANISH_CAP _("Get VANISH Cap")
+#define TEXT_OPT_REMOVE_CAP _("REMOVE Cap")
+#define TEXT_OPT_NORMAL_CAP _("RESET Cap")
+#define TEXT_OPT_BLJ       _("BLJ Anywhere")
+#define TEXT_OPT_PAC   _("Play as")
+#define TEXT_OPT_TRIPLE _("All Jumps Triple")
+#define TEXT_OPT_FLY _("FLYER")
+#define TEXT_OPT_NOB _("No Bounds")
+#define TEXT_OPT_FLJ _("Forward Long Jump")
+#define TEXT_OPT_TS _("Time Stop")
+
+#define TEXT_OPT_COIN1 _("Off")
+#define TEXT_OPT_COIN2 _("Coin")
+#define TEXT_OPT_COIN3 _("Blue Coin")
+#define TEXT_OPT_COIN4 _("Red Coin")
+
+#define TEXT_OPT_SS1   _("Normal")
+#define TEXT_OPT_SS2   _("Slow")
+#define TEXT_OPT_SS3   _("Slower")
+#define TEXT_OPT_SS4   _("Fast")
+#define TEXT_OPT_SS5   _("Faster")
+
+#define TEXT_OPT_PA1    _("Disabled")
+#define TEXT_OPT_PA2    _("Black Bobomb")
+#define TEXT_OPT_PA3    _("Pink Bobomb")
+#define TEXT_OPT_PA4    _("Goomba")
+#define TEXT_OPT_PA5    _("Koopa Shell")
+#define TEXT_OPT_PA6    _("Chuckya")
+#define TEXT_OPT_PA7    _("FlyGuy")
+#define TEXT_OPT_PA8    _("Per Level")
+
+#define TEXT_OPT_SEQ1    _("Intro")
+#define TEXT_OPT_SEQ2    _("Grass")
+#define TEXT_OPT_SEQ3    _("Castle")
+#define TEXT_OPT_SEQ4    _("Water")
+#define TEXT_OPT_SEQ5    _("Hot")
+#define TEXT_OPT_SEQ6    _("Bowser")
+#define TEXT_OPT_SEQ7    _("Snow")
+#define TEXT_OPT_SEQ8    _("Slide")
+#define TEXT_OPT_SEQ9    _("Spooky")
+#define TEXT_OPT_SEQ10   _("Underground")
+#define TEXT_OPT_SEQ11   _("Koopa Road")
+#define TEXT_OPT_SEQ12   _("Rainbow Bowser")
+#define TEXT_OPT_SEQ13   _("Goddard")
+#define TEXT_OPT_SEQ14   _("File Select")
+#define TEXT_OPT_SEQ15   _("Powerup")
+#define TEXT_OPT_SEQ16   _("Metal Cap")
+#define TEXT_OPT_SEQ17   _("Boss")
+#define TEXT_OPT_SEQ18   _("MerryGoRound")
+#define TEXT_OPT_SEQ19   _("Credits")
+
+#define TEXT_OPT_HURTCHT1  _("Disabled")
+#define TEXT_OPT_HURTCHT2  _("Burn")
+#define TEXT_OPT_HURTCHT3  _("Shock")
+#define TEXT_OPT_HURTCHT4  _("One HP")
+
+#define TEXT_OPT_SPAMCHT1  _("Disabled")
+#define TEXT_OPT_SPAMCHT2  _("Amp")
+#define TEXT_OPT_SPAMCHT3  _("Blue Coin Switch")
+#define TEXT_OPT_SPAMCHT4  _("Bowling Ball")
+#define TEXT_OPT_SPAMCHT5  _("Breakable box, large")
+#define TEXT_OPT_SPAMCHT6  _("Breakable box, small")
+#define TEXT_OPT_SPAMCHT7  _("Jumping Box")
+#define TEXT_OPT_SPAMCHT8  _("Checkerboard Platform")
+#define TEXT_OPT_SPAMCHT9  _("Chuckya")
+#define TEXT_OPT_SPAMCHT10 _("FlyGuy")
+#define TEXT_OPT_SPAMCHT11 _("Goombas")
+#define TEXT_OPT_SPAMCHT12 _("Heart")
+#define TEXT_OPT_SPAMCHT13 _("Metal Box")
+#define TEXT_OPT_SPAMCHT14 _("Purple Switch")
+
+#define TEXT_OPT_BLJCHT1  _("Disabled")
+#define TEXT_OPT_BLJCHT2  _("Enabled")
+#define TEXT_OPT_BLJCHT3  _("Enabled - Boost: 1")
+#define TEXT_OPT_BLJCHT4  _("Enabled - Boost: 2")
+#define TEXT_OPT_BLJCHT5  _("Enabled - Boost: 3")
+#define TEXT_OPT_BLJCHT6  _("Enabled - Boost: 4")
+#define TEXT_OPT_BLJCHT7  _("Enabled - Boost: 5")
+#define TEXT_OPT_BLJCHT8  _("Rapid Fire")
+#define TEXT_OPT_BLJCHT9  _("Rapid Fire - Boost: 1")
+#define TEXT_OPT_BLJCHT10 _("Rapid Fire - Boost: 2")
+#define TEXT_OPT_BLJCHT11 _("Rapid Fire - Boost: 3")
+#define TEXT_OPT_BLJCHT12 _("Rapid Fire - Boost: 4")
+#define TEXT_OPT_BLJCHT13 _("Rapid Fire - Boost: 5")
+
+#endif // VERSION
+
+#endif // TEXT_CHEATS_STRINGS_H
diff --git a/include/text_options_strings.h.in b/include/text_options_strings.h.in
index 8c6732e..0da9bc3 100644
--- a/include/text_options_strings.h.in
+++ b/include/text_options_strings.h.in
@@ -8,8 +8,9 @@
 #define TEXT_OPT_OPTIONS   _("OPTIONS")
 #define TEXT_OPT_CAMERA    _("CAMERA")
+#define TEXT_OPT_CHEATS    _("CHEATS")
 #define TEXT_OPT_CONTROLS  _("CONTROLS")
 #define TEXT_OPT_VIDEO     _("DISPLAY")
 #define TEXT_OPT_AUDIO     _("SOUND")
-#define TEXT_OPT_CHEATS    _("CHEATS")
+
 
 // Markers
diff --git a/include/text_strings.h.in b/include/text_strings.h.in
index e5065c5..2b46960 100644
--- a/include/text_strings.h.in
+++ b/include/text_strings.h.in
@@ -2,4 +2,5 @@
 #define TEXT_STRINGS_H
 
+#include "text_cheats_strings.h"
 #include "text_menu_strings.h"
 
diff --git a/levels/bowser_1/script.c b/levels/bowser_1/script.c
index e70de99..10da148 100644
--- a/levels/bowser_1/script.c
+++ b/levels/bowser_1/script.c
@@ -23,6 +23,9 @@ const LevelScript level_bowser_1_entry[] = {
     LOAD_MIO0(/*seg*/ 0x06, _group12_mio0SegmentRomStart, _group12_mio0SegmentRomEnd),
     LOAD_RAW( /*seg*/ 0x0D, _group12_geoSegmentRomStart, _group12_geoSegmentRomEnd),
+    LOAD_MIO0(/*seg*/ 0x08, _common0_mio0SegmentRomStart, _common0_mio0SegmentRomEnd),
+    LOAD_RAW(/*seg*/ 0x0F, _common0_geoSegmentRomStart, _common0_geoSegmentRomEnd),
     ALLOC_LEVEL_POOL(),
     MARIO(/*model*/ MODEL_MARIO, /*behParam*/ 0x00000001, /*beh*/ bhvMario),
+    JUMP_LINK(script_func_global_1),
     JUMP_LINK(script_func_global_13),
     LOAD_MODEL_FROM_GEO(MODEL_LEVEL_GEOMETRY_03, bowser_1_yellow_sphere_geo),
diff --git a/levels/bowser_2/script.c b/levels/bowser_2/script.c
index b848c00..984dfde 100644
--- a/levels/bowser_2/script.c
+++ b/levels/bowser_2/script.c
@@ -33,6 +33,9 @@ const LevelScript level_bowser_2_entry[] = {
     LOAD_MIO0(        /*seg*/ 0x06, _group12_mio0SegmentRomStart, _group12_mio0SegmentRomEnd),
     LOAD_RAW(         /*seg*/ 0x0D, _group12_geoSegmentRomStart, _group12_geoSegmentRomEnd),
+    LOAD_MIO0(        /*seg*/ 0x08, _common0_mio0SegmentRomStart, _common0_mio0SegmentRomEnd),
+    LOAD_RAW(         /*seg*/ 0x0F, _common0_geoSegmentRomStart, _common0_geoSegmentRomEnd),
     ALLOC_LEVEL_POOL(),
     MARIO(/*model*/ MODEL_MARIO, /*behParam*/ 0x00000001, /*beh*/ bhvMario),
+    JUMP_LINK(script_func_global_1),
     JUMP_LINK(script_func_global_13),
     LOAD_MODEL_FROM_GEO(MODEL_BOWSER_2_TILTING_ARENA, bowser_2_geo_000170),
diff --git a/levels/bowser_3/script.c b/levels/bowser_3/script.c
index 756ef81..c87e6a5 100644
--- a/levels/bowser_3/script.c
+++ b/levels/bowser_3/script.c
@@ -41,6 +41,9 @@ const LevelScript level_bowser_3_entry[] = {
     LOAD_RAW( /*seg*/ 0x0D, _group12_geoSegmentRomStart,  _group12_geoSegmentRomEnd),
     LOAD_MIO0(/*seg*/ 0x0A, _bits_skybox_mio0SegmentRomStart, _bits_skybox_mio0SegmentRomEnd),
+    LOAD_MIO0(/*seg*/ 0x08, _common0_mio0SegmentRomStart, _common0_mio0SegmentRomEnd),
+    LOAD_RAW(/*seg*/ 0x0F, _common0_geoSegmentRomStart, _common0_geoSegmentRomEnd),
     ALLOC_LEVEL_POOL(),
     MARIO(/*model*/ MODEL_MARIO, /*behParam*/ 0x00000001, /*beh*/ bhvMario),
+    JUMP_LINK(script_func_global_1),
     JUMP_LINK(script_func_global_13),
     LOAD_MODEL_FROM_GEO(MODEL_BOWSER_3_FALLING_PLATFORM_1,  bowser_3_geo_000290),
diff --git a/levels/castle_inside/script.c b/levels/castle_inside/script.c
index 5d9ae4f..1792886 100644
--- a/levels/castle_inside/script.c
+++ b/levels/castle_inside/script.c
@@ -226,6 +226,9 @@ const LevelScript level_castle_inside_entry[] = {
     LOAD_MIO0(        /*seg*/ 0x06, _group15_mio0SegmentRomStart, _group15_mio0SegmentRomEnd),
     LOAD_RAW(         /*seg*/ 0x0D, _group15_geoSegmentRomStart,  _group15_geoSegmentRomEnd),
+    LOAD_MIO0(        /*seg*/ 0x08, _common0_mio0SegmentRomStart, _common0_mio0SegmentRomEnd),
+    LOAD_RAW(         /*seg*/ 0x0F, _common0_geoSegmentRomStart, _common0_geoSegmentRomEnd),
     ALLOC_LEVEL_POOL(),
     MARIO(/*model*/ MODEL_MARIO, /*behParam*/ 0x00000001, /*beh*/ bhvMario),
+    JUMP_LINK(script_func_global_1),
     JUMP_LINK(script_func_global_16),
     LOAD_MODEL_FROM_GEO(MODEL_CASTLE_BOWSER_TRAP,        castle_geo_000F18),
diff --git a/levels/sa/script.c b/levels/sa/script.c
index 57dd301..a82902f 100644
--- a/levels/sa/script.c
+++ b/levels/sa/script.c
@@ -37,6 +37,9 @@ const LevelScript level_sa_entry[] = {
     LOAD_MIO0(        /*seg*/ 0x06, _group13_mio0SegmentRomStart, _group13_mio0SegmentRomEnd),
     LOAD_RAW(         /*seg*/ 0x0D, _group13_geoSegmentRomStart,  _group13_geoSegmentRomEnd),
+    LOAD_MIO0(/*seg*/ 0x08, _common0_mio0SegmentRomStart, _common0_mio0SegmentRomEnd),
+    LOAD_RAW(/*seg*/ 0x0F, _common0_geoSegmentRomStart, _common0_geoSegmentRomEnd),
     ALLOC_LEVEL_POOL(),
     MARIO(/*model*/ MODEL_MARIO, /*behParam*/ 0x00000001, /*beh*/ bhvMario),
+    JUMP_LINK(script_func_global_1),
     JUMP_LINK(script_func_global_5),
     JUMP_LINK(script_func_global_14),
diff --git a/src/engine/surface_collision.c b/src/engine/surface_collision.c
index 1da535b..80df321 100644
--- a/src/engine/surface_collision.c
+++ b/src/engine/surface_collision.c
@@ -6,4 +6,5 @@
 #include "game/mario.h"
 #include "game/object_list_processor.h"
+#include "pc/cheats.h"
 #include "surface_collision.h"
 #include "surface_load.h"
@@ -41,4 +42,9 @@ static s32 find_wall_collisions_from_list(struct SurfaceNode *surfaceNode,
         surfaceNode = surfaceNode->next;
 
+        /*No Clip Cheats*/
+        if (Cheats.EnableCheats && Cheats.NoBounds) {
+            continue;
+        }
+
         // Exclude a large number of walls immediately to optimize.
         if (y < surf->lowerY || y > surf->upperY) {
@@ -171,5 +177,10 @@ s32 f32_find_wall_collision(f32 *xPtr, f32 *yPtr, f32 *zPtr, f32 offsetY, f32 ra
     collision.numWalls = 0;
 
-    numCollisions = find_wall_collisions(&collision);
+    /*No Clip Cheats*/
+    if (Cheats.EnableCheats && Cheats.NoBounds) {
+        numCollisions = 0;
+    } else {
+        numCollisions = find_wall_collisions(&collision);
+    }
 
     *xPtr = collision.x;
@@ -192,4 +203,8 @@ s32 find_wall_collisions(struct WallCollisionData *colData) {
     colData->numWalls = 0;
 
+    if (Cheats.EnableCheats && Cheats.NoBounds) {
+        return numCollisions;
+    }
+
     if (x <= -LEVEL_BOUNDARY_MAX || x >= LEVEL_BOUNDARY_MAX) {
         return numCollisions;
@@ -237,4 +252,8 @@ static struct Surface *find_ceil_from_list(struct SurfaceNode *surfaceNode, s32
         surfaceNode = surfaceNode->next;
 
+        if (Cheats.EnableCheats && Cheats.NoBounds) {
+            continue;
+        }
+
         x1 = surf->vertex1[0];
         z1 = surf->vertex1[2];
@@ -321,4 +340,8 @@ f32 find_ceil(f32 posX, f32 posY, f32 posZ, struct Surface **pceil) {
     *pceil = NULL;
 
+    if (Cheats.EnableCheats && Cheats.NoBounds) {
+        return height;
+    }
+
     if (x <= -LEVEL_BOUNDARY_MAX || x >= LEVEL_BOUNDARY_MAX) {
         return height;
diff --git a/src/game/cheats_menu.h b/src/game/cheats_menu.h
new file mode 100644
index 0000000..0550549
--- /dev/null
+++ b/src/game/cheats_menu.h
@@ -0,0 +1,215 @@
+#ifndef CHEATS_MENU_H
+#define CHEATS_MENU_H
+
+static const u8 optsCoinCheatStr[][32] = {
+    { TEXT_OPT_COIN1 },
+    { TEXT_OPT_COIN2 },
+    { TEXT_OPT_COIN3 },
+    { TEXT_OPT_COIN4 },
+};
+
+static const u8 *CoinChoices[] = {
+    optsCoinCheatStr[0],
+    optsCoinCheatStr[1],
+    optsCoinCheatStr[2],
+    optsCoinCheatStr[3],
+};
+
+static const u8 optsSeqStr[][64] = {
+    { TEXT_OPT_SEQ1 },
+    { TEXT_OPT_SEQ2 },
+    { TEXT_OPT_SEQ3 },
+    { TEXT_OPT_SEQ4 },
+    { TEXT_OPT_SEQ5 },
+    { TEXT_OPT_SEQ6 },
+    { TEXT_OPT_SEQ7 },
+    { TEXT_OPT_SEQ8 },
+    { TEXT_OPT_SEQ9 },
+    { TEXT_OPT_SEQ10 },
+    { TEXT_OPT_SEQ11 },
+    { TEXT_OPT_SEQ12 },
+    { TEXT_OPT_SEQ13 },
+    { TEXT_OPT_SEQ14 },
+    { TEXT_OPT_SEQ15 },
+    { TEXT_OPT_SEQ16 },
+    { TEXT_OPT_SEQ17 },
+    { TEXT_OPT_SEQ18 },
+    { TEXT_OPT_SEQ19 },
+};
+
+static const u8 *SeqChoices[] = {
+    optsSeqStr[0],
+    optsSeqStr[1],
+    optsSeqStr[2],
+    optsSeqStr[3],
+    optsSeqStr[4],
+    optsSeqStr[5],
+    optsSeqStr[6],
+    optsSeqStr[7],
+    optsSeqStr[8],
+    optsSeqStr[9],
+    optsSeqStr[10],
+    optsSeqStr[11],
+    optsSeqStr[12],
+    optsSeqStr[13],
+    optsSeqStr[14],
+    optsSeqStr[15],
+    optsSeqStr[16],
+    optsSeqStr[17],
+    optsSeqStr[18],
+};
+
+static const u8 optsSpeedStr[][16] = {
+    { TEXT_OPT_SS1 },
+    { TEXT_OPT_SS2 },
+    { TEXT_OPT_SS3 },
+    { TEXT_OPT_SS4 },
+    { TEXT_OPT_SS5 },
+};
+
+static const u8 *SpeedChoices[] = {
+    optsSpeedStr[0],
+    optsSpeedStr[1],
+    optsSpeedStr[2],
+    optsSpeedStr[3],
+    optsSpeedStr[4],
+};
+
+static const u8 optsPlayAsCheatStr[][32] = {
+    { TEXT_OPT_PA1 },
+    { TEXT_OPT_PA2 },
+    { TEXT_OPT_PA3 },
+    { TEXT_OPT_PA4 },
+    { TEXT_OPT_PA5 },
+    { TEXT_OPT_PA6 },
+    { TEXT_OPT_PA7 },
+    { TEXT_OPT_PA8 },
+};
+
+static const u8* PlayAsCheatChoices[] = {
+    optsPlayAsCheatStr[0],
+    optsPlayAsCheatStr[1],
+    optsPlayAsCheatStr[2],
+    optsPlayAsCheatStr[3],
+    optsPlayAsCheatStr[4],
+    optsPlayAsCheatStr[5],
+    optsPlayAsCheatStr[6],
+    optsPlayAsCheatStr[7],
+};
+
+
+static const u8 optsHurtCheatStr[][32] = {
+    { TEXT_OPT_HURTCHT1 },
+    { TEXT_OPT_HURTCHT2 },
+    { TEXT_OPT_HURTCHT3 },
+    { TEXT_OPT_HURTCHT4 },
+};
+
+static const u8* HurtCheatChoices[] = {
+    optsHurtCheatStr[0],
+    optsHurtCheatStr[1],
+    optsHurtCheatStr[2],
+    optsHurtCheatStr[3],
+};
+
+static const u8 optsSpamCheatStr[][32] = {
+    { TEXT_OPT_SPAMCHT1 },
+    { TEXT_OPT_SPAMCHT2 },
+    { TEXT_OPT_SPAMCHT3 },
+    { TEXT_OPT_SPAMCHT4 },
+    { TEXT_OPT_SPAMCHT5 },
+    { TEXT_OPT_SPAMCHT6 },
+    { TEXT_OPT_SPAMCHT7 },
+    { TEXT_OPT_SPAMCHT8 },
+    { TEXT_OPT_SPAMCHT9 },
+    { TEXT_OPT_SPAMCHT10 },
+    { TEXT_OPT_SPAMCHT11 },
+    { TEXT_OPT_SPAMCHT12 },
+    { TEXT_OPT_SPAMCHT13 },
+    { TEXT_OPT_SPAMCHT14 },
+};
+
+static const u8* SpamCheatChoices[] = {
+    optsSpamCheatStr[0],
+    optsSpamCheatStr[1],
+    optsSpamCheatStr[2],
+    optsSpamCheatStr[3],
+    optsSpamCheatStr[4],
+    optsSpamCheatStr[5],
+    optsSpamCheatStr[6],
+    optsSpamCheatStr[7],
+    optsSpamCheatStr[8],
+    optsSpamCheatStr[9],
+    optsSpamCheatStr[10],
+    optsSpamCheatStr[11],
+    optsSpamCheatStr[12],
+    optsSpamCheatStr[13],
+};
+
+static const u8 optsBLJCheatStr[][32] = {
+    { TEXT_OPT_BLJCHT1 },
+    { TEXT_OPT_BLJCHT2 },
+    { TEXT_OPT_BLJCHT3 },
+    { TEXT_OPT_BLJCHT4 },
+    { TEXT_OPT_BLJCHT5 },
+    { TEXT_OPT_BLJCHT6 },
+    { TEXT_OPT_BLJCHT7 },
+    { TEXT_OPT_BLJCHT8 },
+    { TEXT_OPT_BLJCHT9 },
+    { TEXT_OPT_BLJCHT10 },
+    { TEXT_OPT_BLJCHT11 },
+    { TEXT_OPT_BLJCHT12 },
+    { TEXT_OPT_BLJCHT13 },
+};
+
+static const u8* bljCheatChoices[] = {
+    optsBLJCheatStr[0],
+    optsBLJCheatStr[1],
+    optsBLJCheatStr[2],
+    optsBLJCheatStr[3],
+    optsBLJCheatStr[4],
+    optsBLJCheatStr[5],
+    optsBLJCheatStr[6],
+    optsBLJCheatStr[7],
+    optsBLJCheatStr[8],
+    optsBLJCheatStr[9],
+    optsBLJCheatStr[10],
+    optsBLJCheatStr[11],
+    optsBLJCheatStr[12],
+};
+
+static const u8 optsCheatsStr2[][64] = {
+    { TEXT_OPT_COIN },
+    { TEXT_OPT_HOVER },
+    { TEXT_OPT_MOON },
+    { TEXT_OPT_RUN },
+    { TEXT_OPT_NDB },
+    { TEXT_OPT_JUMP },
+    { TEXT_OPT_SPDDPS },
+    { TEXT_OPT_TPF },
+    { TEXT_OPT_JB },
+    { TEXT_OPT_JBC },
+    { TEXT_OPT_QUIKEND },
+    { TEXT_OPT_HURT },
+    { TEXT_OPT_CANN },
+    { TEXT_OPT_AWK },
+    { TEXT_OPT_SHELL },
+    { TEXT_OPT_BOB },
+    { TEXT_OPT_SPAMBA },
+    { TEXT_OPT_SWIM },
+    { TEXT_OPT_WING_CAP },
+    { TEXT_OPT_METAL_CAP },
+    { TEXT_OPT_VANISH_CAP },
+    { TEXT_OPT_REMOVE_CAP },
+    { TEXT_OPT_NORMAL_CAP },
+    { TEXT_OPT_BLJ },
+    { TEXT_OPT_PAC },
+    { TEXT_OPT_TRIPLE },
+    { TEXT_OPT_FLY },
+    { TEXT_OPT_NOB },
+    { TEXT_OPT_FLJ },
+    { TEXT_OPT_TS },
+
+};
+
+#endif // CHEATS_MENU_H
diff --git a/src/game/interaction.c b/src/game/interaction.c
index 7a9c520..28323df 100644
--- a/src/game/interaction.c
+++ b/src/game/interaction.c
@@ -1,4 +1,5 @@
 #include <PR/ultratypes.h>
 
+#include "pc/cheats.h"
 #include "area.h"
 #include "actors/common1.h"
@@ -15,4 +16,5 @@
 #include "level_update.h"
 #include "mario.h"
+#include "mario_cheats.h"
 #include "mario_step.h"
 #include "memory.h"
@@ -1778,19 +1780,24 @@ void mario_process_interactions(struct MarioState *m) {
 
 void check_death_barrier(struct MarioState *m) {
-    if (m->pos[1] < m->floorHeight + 2048.0f) {
-        if (level_trigger_warp(m, WARP_OP_WARP_FLOOR) == 20 && !(m->flags & MARIO_UNKNOWN_18)) {
-            play_sound(SOUND_MARIO_WAAAOOOW, m->marioObj->header.gfx.cameraToObject);
+    while (Cheats.NDB == false) {
+        if (m->pos[1] < m->floorHeight + 2048.0f) {
+            if (level_trigger_warp(m, WARP_OP_WARP_FLOOR) == 20 && !(m->flags & MARIO_UNKNOWN_18)) {
+                play_sound(SOUND_MARIO_WAAAOOOW, m->marioObj->header.gfx.cameraToObject);
+            }
         }
+        break;
     }
 }
 
 void check_lava_boost(struct MarioState *m) {
-    if (!(m->action & ACT_FLAG_RIDING_SHELL) && m->pos[1] < m->floorHeight + 10.0f) {
-        if (!(m->flags & MARIO_METAL_CAP)) {
-            m->hurtCounter += (m->flags & MARIO_CAP_ON_HEAD) ? 12 : 18;
-        }
+    if (HAZ_WALK != 1) {
+        if (!(m->action & ACT_FLAG_RIDING_SHELL) && m->pos[1] < m->floorHeight + 10.0f) {
+            if (!(m->flags & MARIO_METAL_CAP)) {
+                m->hurtCounter += (m->flags & MARIO_CAP_ON_HEAD) ? 12 : 18;
+            }
 
-        update_mario_sound_and_camera(m);
-        drop_and_set_mario_action(m, ACT_LAVA_BOOST, 0);
+            update_mario_sound_and_camera(m);
+            drop_and_set_mario_action(m, ACT_LAVA_BOOST, 0);
+        }
     }
 }
@@ -1846,4 +1853,7 @@ void mario_handle_special_floors(struct MarioState *m) {
             switch (floorType) {
                 case SURFACE_BURNING:
+                    if (Cheats.EnableCheats && HAZ_WALK == 1) {
+                        break;
+                    }
                     check_lava_boost(m);
                     break;
diff --git a/src/game/mario.c b/src/game/mario.c
index 5f8e511..2b23191 100644
--- a/src/game/mario.c
+++ b/src/game/mario.c
@@ -1,4 +1,5 @@
 #include <PR/ultratypes.h>
 
+#include "mario_cheats.h"
 #include "sm64.h"
 #include "area.h"
@@ -878,5 +879,5 @@ static u32 set_mario_action_airborne(struct MarioState *m, u32 action, u32 actio
             //! (BLJ's) This properly handles long jumps from getting forward speed with
             //  too much velocity, but misses backwards longs allowing high negative speeds.
-            if ((m->forwardVel *= 1.5f) > 48.0f) {
+            if ((m->forwardVel *= 1.5f) > 48.0f && !(Cheats.EnableCheats && Cheats.FLJ)) {
                 m->forwardVel = 48.0f;
             }
@@ -1224,4 +1225,8 @@ void squish_mario_model(struct MarioState *m) {
                 else if (Cheats.TinyMario) {
                     vec3f_set(m->marioObj->header.gfx.scale, 0.2f, 0.2f, 0.2f);
+                } else if (Cheats.PAC == 3) {
+                    vec3f_set(m->marioObj->header.gfx.scale, 1.5f, 1.5f, 1.5f);
+                } else if (Cheats.PAC == 5) {
+                    vec3f_set(m->marioObj->header.gfx.scale, 1.5f, 1.5f, 1.5f);
                 }
                 else {
@@ -1414,5 +1419,7 @@ void update_mario_inputs(struct MarioState *m) {
 
     debug_print_speed_action_normal(m);
-    
+
+    cheats_mario_inputs(m);
+
     /* Moonjump cheat */
     while (Cheats.MoonJump == true && Cheats.EnableCheats == true && m->controller->buttonDown & L_TRIG ){
@@ -1689,4 +1696,6 @@ void mario_update_hitbox_and_cap_model(struct MarioState *m) {
     if (m->action & ACT_FLAG_SHORT_HITBOX) {
         m->marioObj->hitboxHeight = 100.0f;
+    } else if (Cheats.EnableCheats && Cheats.PAC > 0) {
+        m->marioObj->hitboxHeight = 120.0f;
     } else {
         m->marioObj->hitboxHeight = 160.0f;
diff --git a/src/game/mario_actions_airborne.c b/src/game/mario_actions_airborne.c
index 17e45ae..898d385 100644
--- a/src/game/mario_actions_airborne.c
+++ b/src/game/mario_actions_airborne.c
@@ -1,4 +1,6 @@
 #include <PR/ultratypes.h>
 
+#include "mario_cheats.h"
+#include "pc/cheats.h"
 #include "sm64.h"
 #include "area.h"
@@ -333,6 +335,13 @@ void update_flying(struct MarioState *m) {
     update_flying_yaw(m);
 
-    m->forwardVel -= 2.0f * ((f32) m->faceAngle[0] / 0x4000) + 0.1f;
+    /*Flyer Cheat*/
+    if (Cheats.Fly) {
+        if (m->forwardVel < 30.0f) {
+            m->forwardVel += 2.0f;
+        }
+    }
     m->forwardVel -= 0.5f * (1.0f - coss(m->angleVel[1]));
+    m->forwardVel -= 2.0f * ((f32) m->faceAngle[0] / 0x4000) + 0.1f;
+
 
     if (m->forwardVel < 0.0f) {
@@ -373,4 +382,6 @@ u32 common_air_action_step(struct MarioState *m, u32 landAction, s32 animation,
     switch (stepResult) {
         case AIR_STEP_NONE:
+            // BLJ anywhere cheat
+            cheats_air_step(m);
             set_mario_animation(m, animation);
             break;
@@ -910,5 +921,11 @@ s32 act_ground_pound(struct MarioState *m) {
         if (m->actionTimer < 10) {
             yOffset = 20 - 2 * m->actionTimer;
-            if (m->pos[1] + yOffset + 160.0f < m->ceilHeight) {
+            if (Cheats.EnableCheats && Cheats.PAC > 0) {
+                if (m->pos[1] + yOffset + 120.0f < m->ceilHeight) {
+                    m->pos[1] += yOffset;
+                    m->peakHeight = m->pos[1];
+                    vec3f_copy(m->marioObj->header.gfx.pos, m->pos);
+                }
+            } else if (m->pos[1] + yOffset + 160.0f < m->ceilHeight) {
                 m->pos[1] += yOffset;
                 m->peakHeight = m->pos[1];
diff --git a/src/game/mario_actions_automatic.c b/src/game/mario_actions_automatic.c
index a74f4a1..c9ec20e 100644
--- a/src/game/mario_actions_automatic.c
+++ b/src/game/mario_actions_automatic.c
@@ -2,4 +2,5 @@
 
 #include "sm64.h"
+#include "pc/cheats.h"
 #include "behavior_data.h"
 #include "mario_actions_automatic.h"
@@ -81,5 +82,10 @@ s32 set_pole_position(struct MarioState *m, f32 offsetY) {
 
     ceilHeight = vec3f_find_ceil(m->pos, m->pos[1], &ceil);
-    if (m->pos[1] > ceilHeight - 160.0f) {
+    if (Cheats.EnableCheats && Cheats.PAC > 0) {
+        if (m->pos[1] > ceilHeight - 120.0f) {
+            m->pos[1] = ceilHeight - 120.0f;
+            marioObj->oMarioPolePos = m->pos[1] - m->usedObj->oPosY;
+        }
+    } else if (m->pos[1] > ceilHeight - 160.0f) {
         m->pos[1] = ceilHeight - 160.0f;
         marioObj->oMarioPolePos = m->pos[1] - m->usedObj->oPosY;
diff --git a/src/game/mario_actions_cutscene.c b/src/game/mario_actions_cutscene.c
index 72e7692..5c14f8e 100644
--- a/src/game/mario_actions_cutscene.c
+++ b/src/game/mario_actions_cutscene.c
@@ -552,16 +552,16 @@ s32 act_debug_free_move(struct MarioState *m) {
 
     // integer immediates, generates convert instructions for some reason
-    speed = gPlayer1Controller->buttonDown & B_BUTTON ? 4 : 1;
-    if (gPlayer1Controller->buttonDown & L_TRIG) {
+    speed = gPlayer1Controller->buttonDown & L_TRIG ? 4 : 1;
+    if (gPlayer1Controller->buttonDown & R_TRIG) {
         speed = 0.01f;
     }
 
-    set_mario_animation(m, MARIO_ANIM_A_POSE);
+    set_mario_animation(m, MARIO_ANIM_BREAKDANCE);
     vec3f_copy(pos, m->pos);
 
-    if (gPlayer1Controller->buttonDown & U_JPAD) {
+    if (gPlayer1Controller->buttonDown & A_BUTTON) {
         pos[1] += 16.0f * speed;
     }
-    if (gPlayer1Controller->buttonDown & D_JPAD) {
+    if (gPlayer1Controller->buttonDown & Z_TRIG) {
         pos[1] -= 16.0f * speed;
     }
@@ -586,5 +586,5 @@ s32 act_debug_free_move(struct MarioState *m) {
     vec3s_set(m->marioObj->header.gfx.angle, 0, m->faceAngle[1], 0);
 
-    if (gPlayer1Controller->buttonPressed == A_BUTTON) {
+    if (gPlayer1Controller->buttonPressed == B_BUTTON) {
         if (m->pos[1] <= m->waterLevel - 100) {
             action = ACT_WATER_IDLE;
diff --git a/src/game/mario_actions_moving.c b/src/game/mario_actions_moving.c
index 0ccbccf..035a88f 100644
--- a/src/game/mario_actions_moving.c
+++ b/src/game/mario_actions_moving.c
@@ -10,4 +10,5 @@
 #include "interaction.h"
 #include "mario_actions_object.h"
+#include "mario_cheats.h"
 #include "memory.h"
 #include "behavior_data.h"
@@ -1867,4 +1868,5 @@ s32 act_long_jump_land(struct MarioState *m) {
     }
 
+    cheats_long_jump(m);
     common_landing_action(m,
                           !m->marioObj->oMarioLongJumpIsSlow ? MARIO_ANIM_CROUCH_FROM_FAST_LONGJUMP
diff --git a/src/game/mario_actions_submerged.c b/src/game/mario_actions_submerged.c
index f03e4a9..3626bad 100644
--- a/src/game/mario_actions_submerged.c
+++ b/src/game/mario_actions_submerged.c
@@ -1,4 +1,5 @@
 #include <PR/ultratypes.h>
 
+#include "mario_cheats.h"
 #include "sm64.h"
 #include "level_update.h"
@@ -232,4 +233,6 @@ static void update_swimming_speed(struct MarioState *m, f32 decelThreshold) {
     f32 maxSpeed = 28.0f;
 
+    cheats_swimming_speed(m);
+
     if (m->action & ACT_FLAG_STATIONARY) {
         m->forwardVel -= 2.0f;
diff --git a/src/game/mario_cheats.c b/src/game/mario_cheats.c
new file mode 100644
index 0000000..f156529
--- /dev/null
+++ b/src/game/mario_cheats.c
@@ -0,0 +1,1790 @@
+#include <stdlib.h>
+#include <time.h>
+#include <PR/ultratypes.h>
+
+#include "sm64.h"
+#include "area.h"
+#include "actors/common0.h"
+#include "actors/common1.h"
+#include "actors/group0.h"
+#include "actors/group1.h"
+#include "actors/group2.h"
+#include "actors/group4.h"
+#include "actors/group5.h"
+#include "actors/group6.h"
+#include "actors/group7.h"
+#include "actors/group9.h"
+#include "actors/group10.h"
+#include "actors/group11.h"
+#include "actors/group12.h"
+#include "actors/group13.h"
+#include "actors/group14.h"
+#include "actors/group15.h"
+#include "actors/group17.h"
+#include "audio/data.h"
+#include "audio/external.h"
+#include "behavior_actions.h"
+#include "behavior_data.h"
+#include "camera.h"
+#include "engine/behavior_script.h"
+#include "engine/graph_node.h"
+#include "engine/level_script.h"
+#include "engine/math_util.h"
+#include "engine/surface_collision.h"
+#include "game_init.h"
+#include "interaction.h"
+#include "level_table.h"
+#include "level_update.h"
+#include "macros.h"
+#include "main.h"
+#include "mario.h"
+#include "mario_actions_airborne.h"
+#include "mario_actions_automatic.h"
+#include "mario_actions_cutscene.h"
+#include "mario_actions_moving.h"
+#include "mario_actions_object.h"
+#include "mario_actions_stationary.h"
+#include "mario_actions_submerged.h"
+#include "mario_cheats.h"
+#include "mario_misc.h"
+#include "mario_step.h"
+#include "memory.h"
+#include "model_ids.h"
+#include "object_fields.h"
+#include "object_helpers.h"
+#include "object_list_processor.h"
+#include "print.h"
+#include "rendering_graph_node.h"
+#include "save_file.h"
+#include "seq_ids.h"
+#include "sound_init.h"
+#include "debug.h"
+#include "thread6.h"
+#include "pc/configfile.h"
+#include "pc/cheats.h"
+#ifdef R96
+#include "sgi/utils/characters.h"
+#endif // R96
+
+
+#define SwiftSwim 42.0f
+
+/*SwiftSwim Cheat*/
+void cheats_swimming_speed(struct MarioState* m) {
+    while (m->forwardVel < SwiftSwim && Cheats.EnableCheats == true && Cheats.Swim == true) {
+        while (m->controller->buttonDown & A_BUTTON) {
+            m->particleFlags |= PARTICLE_BUBBLE;
+            m->forwardVel += 5.0f;
+            break;
+        }
+        break;
+    }
+}
+
+/*BLJAnywhere Cheat*/
+void cheats_air_step(struct MarioState *m) {
+    if (Cheats.BLJAnywhere > 0 && Cheats.EnableCheats == TRUE && m->action == ACT_LONG_JUMP
+        && m->forwardVel < 1.0f && m->pos[1] - 50.0f < m->floorHeight) {
+        if (Cheats.BLJAnywhere < 7) {
+            if (m->controller->buttonPressed & A_BUTTON) {
+                m->forwardVel -= (Cheats.BLJAnywhere - 1) * 2.5f;
+                m->vel[1] = -50.0f;
+            }
+        } else if (m->controller->buttonDown & A_BUTTON) {
+            m->forwardVel -= (Cheats.BLJAnywhere - 7) * 2.5f;
+            m->vel[1] = -50.0f;
+        }
+    }
+}
+
+void cheats_long_jump(struct MarioState *m) {
+    if (Cheats.BLJAnywhere >= 7 && Cheats.EnableCheats == true && m->forwardVel < 1.0f
+        && (m->controller->buttonDown & A_BUTTON)) {
+        set_jumping_action(m, ACT_LONG_JUMP, 0);
+    }
+}
+
+/*Main cheat function*/
+void cheats_mario_inputs(struct MarioState *m) {
+    m->particleFlags = 0;
+    m->collidedObjInteractTypes = m->marioObj->collidedObjInteractTypes;
+    m->flags &= 0xFFFFFF;
+    u32 r;
+
+    while (Cheats.EnableCheats == true) {
+
+        /*Spamba Per Level*/
+        switch (gCurrLevelNum) {
+            case LEVEL_CASTLE_GROUNDS:
+                switch (SPL) {
+                    case 0:
+                        break;
+                    case 1:
+                        if (m->controller->buttonDown & L_TRIG
+                            && m->controller->buttonPressed & Z_TRIG) {
+                            spawn_object_relative(0, 0, 160, 200, gCurrentObject, MODEL_BIRDS, bhvBird);
+                            break;
+                        }
+                        break;
+                    case 2:
+                    case 3:
+                    case 4:
+                    case 5:
+                    case 6:
+                    case 7:
+                        if (m->controller->buttonDown & L_TRIG
+                            && m->controller->buttonPressed & Z_TRIG) {
+                            play_sound(SOUND_MENU_CAMERA_BUZZ, gDefaultSoundArgs);
+                            break;
+                        }
+                        break;
+                }
+                break;
+            case LEVEL_CASTLE_COURTYARD:
+                switch (SPL) {
+                    case 0:
+                        break;
+                    case 1:
+                        if (m->controller->buttonDown & L_TRIG
+                            && m->controller->buttonPressed & Z_TRIG) {
+                            spawn_object_relative(0, 0, 100, 100, gCurrentObject, MODEL_MAD_PIANO,
+                                                  bhvMadPiano);
+                            break;
+                        }
+                        break;
+                    case 2:
+                        if (m->controller->buttonDown & L_TRIG
+                            && m->controller->buttonPressed & Z_TRIG) {
+                            spawn_object_relative(0, 0, 100, 150, gCurrentObject, MODEL_BOO, bhvBoo);
+                            break;
+                        }
+                        break;
+                    case 3:
+                    case 4:
+                    case 5:
+                    case 6:
+                    case 7:
+                        if (m->controller->buttonDown & L_TRIG
+                            && m->controller->buttonPressed & Z_TRIG) {
+                            play_sound(SOUND_MENU_CAMERA_BUZZ, gDefaultSoundArgs);
+                            break;
+                        }
+                        break;
+                }
+                break;
+            case LEVEL_BITDW:
+                switch (SPL) {
+                    case 0:
+                        break;
+                    case 1:
+                        if (m->controller->buttonDown & L_TRIG
+                            && m->controller->buttonPressed & Z_TRIG) {
+                            spawn_object_relative(0, 0, 100, 100, gCurrentObject, MODEL_BUBBA,
+                                                  bhvBubba);
+                            break;
+                        }
+                        break;
+                    case 2:
+                        if (m->controller->buttonDown & L_TRIG
+                            && m->controller->buttonPressed & Z_TRIG) {
+                            spawn_object_relative(0, 0, 100, 150, gCurrentObject, MODEL_ENEMY_LAKITU,
+                                                  bhvEnemyLakitu);
+                            break;
+                        }
+                        break;
+                    case 3:
+                        if (m->controller->buttonDown & L_TRIG
+                            && m->controller->buttonPressed & Z_TRIG) {
+                            spawn_object_relative(0, 0, 300, 300, gCurrentObject, MODEL_SWOOP,
+                                                  bhvSwoop);
+                            break;
+                        }
+                        break;
+                    case 4:
+                        if (m->controller->buttonDown & L_TRIG
+                            && m->controller->buttonPressed & Z_TRIG) {
+                            spawn_object_relative(0, 0, 100, 200, gCurrentObject, MODEL_SNUFIT,
+                                                  bhvSnufit);
+                            break;
+                        }
+                        break;
+                    case 5:
+                        if (m->controller->buttonDown & L_TRIG
+                            && m->controller->buttonPressed & Z_TRIG) {
+                            spawn_object_relative(0, 0, 10, 200, gCurrentObject, MODEL_DORRIE,
+                                                  bhvDorrie);
+                            break;
+                        }
+                        break;
+                    case 6:
+                        if (m->controller->buttonDown & L_TRIG
+                            && m->controller->buttonPressed & Z_TRIG) {
+                            spawn_object_relative(0, 0, 100, 100, gCurrentObject, MODEL_SCUTTLEBUG,
+                                                  bhvScuttlebug);
+                            break;
+                        }
+                        break;
+                    case 7:
+                        if (m->controller->buttonDown & L_TRIG
+                            && m->controller->buttonPressed & Z_TRIG) {
+                            play_sound(SOUND_MENU_CAMERA_BUZZ, gDefaultSoundArgs);
+                            break;
+                        }
+                        break;
+                }
+                break;
+            case LEVEL_BITFS:
+            case LEVEL_LLL:
+            case LEVEL_WMOTR:
+                switch (SPL) {
+                    case 0:
+                        break;
+                    case 1:
+                        if (m->controller->buttonDown & L_TRIG
+                            && m->controller->buttonPressed & Z_TRIG) {
+                            spawn_object_relative(0, 0, 100, 100, gCurrentObject, MODEL_BULLY,
+                                                  bhvSmallBully);
+                            break;
+                        }
+                        break;
+                    case 2:
+                        if (m->controller->buttonDown & L_TRIG
+                            && m->controller->buttonPressed & Z_TRIG) {
+                            spawn_object_relative(0, 0, 300, 300, gCurrentObject, MODEL_SWOOP,
+                                                  bhvSwoop);
+                            break;
+                        }
+                        break;
+                    case 3:
+                        if (m->controller->buttonDown & L_TRIG
+                            && m->controller->buttonPressed & Z_TRIG) {
+                            spawn_object_relative(0, 0, 100, 200, gCurrentObject, MODEL_SNUFIT,
+                                                  bhvSnufit);
+                            break;
+                        }
+                        break;
+                    case 4:
+                        if (m->controller->buttonDown & L_TRIG
+                            && m->controller->buttonPressed & Z_TRIG) {
+                            spawn_object_relative(0, 0, 10, 200, gCurrentObject, MODEL_DORRIE,
+                                                  bhvDorrie);
+                            break;
+                        }
+                        break;
+                    case 5:
+                        if (m->controller->buttonDown & L_TRIG
+                            && m->controller->buttonPressed & Z_TRIG) {
+                            spawn_object_relative(0, 0, 100, 100, gCurrentObject, MODEL_SCUTTLEBUG,
+                                                  bhvScuttlebug);
+                            break;
+                        }
+                        break;
+                    case 6:
+                    case 7:
+                        if (m->controller->buttonDown & L_TRIG
+                            && m->controller->buttonPressed & Z_TRIG) {
+                            play_sound(SOUND_MENU_CAMERA_BUZZ, gDefaultSoundArgs);
+                            break;
+                        }
+                        break;
+                }
+                break;
+            case LEVEL_BITS:
+                switch (SPL) {
+                    case 0:
+                        break;
+                    case 1:
+                        if (m->controller->buttonDown & L_TRIG
+                            && m->controller->buttonPressed & Z_TRIG) {
+                            spawn_object_relative(0, 0, 100, 100, gCurrentObject,
+                                                  MODEL_KOOPA_WITH_SHELL, bhvKoopa);
+                            break;
+                        }
+                        break;
+                    case 2:
+                        if (m->controller->buttonDown & L_TRIG
+                            && m->controller->buttonPressed & Z_TRIG) {
+                            spawn_object_relative(0, 0, 10, 200, gCurrentObject, MODEL_PIRANHA_PLANT,
+                                                  bhvPiranhaPlant);
+                            break;
+                        }
+                        break;
+                    case 3:
+                        if (m->controller->buttonDown & L_TRIG
+                            && m->controller->buttonPressed & Z_TRIG) {
+                            spawn_object_relative(0, 0, 100, 100, gCurrentObject, MODEL_WHOMP,
+                                                  bhvSmallWhomp);
+                            break;
+                        }
+                        break;
+                    case 4:
+                        if (m->controller->buttonDown & L_TRIG
+                            && m->controller->buttonPressed & Z_TRIG) {
+                            spawn_object_relative(0, 0, 100, 300, gCurrentObject, MODEL_CHAIN_CHOMP,
+                                                  bhvChainChomp);
+                            break;
+                        }
+                        break;
+                    case 5:
+                    case 6:
+                    case 7:
+                        if (m->controller->buttonDown & L_TRIG
+                            && m->controller->buttonPressed & Z_TRIG) {
+                            play_sound(SOUND_MENU_CAMERA_BUZZ, gDefaultSoundArgs);
+                            break;
+                        }
+                        break;
+                }
+                break;
+            case LEVEL_BOWSER_1:
+            case LEVEL_BOWSER_2:
+            case LEVEL_BOWSER_3:
+                switch (SPL) {
+                    case 0:
+                        break;
+                    case 1:
+                        if (m->controller->buttonDown & L_TRIG
+                            && m->controller->buttonPressed & Z_TRIG) {
+                            spawn_object_relative(0, 0, 200, 200, gCurrentObject, MODEL_BOWSER,
+                                                  bhvBowser);
+                            break;
+                        }
+                        break;
+                    case 2:
+                        if (m->controller->buttonDown & L_TRIG
+                            && m->controller->buttonPressed & Z_TRIG) {
+                            spawn_object_relative(0, 0, 200, 200, gCurrentObject,
+                                                  MODEL_BOWSER_BOMB_CHILD_OBJ, bhvBowserBomb);
+                            break;
+                        }
+                        break;
+                    case 3:
+                    case 4:
+                    case 5:
+                    case 6:
+                    case 7:
+                        if (m->controller->buttonDown & L_TRIG
+                            && m->controller->buttonPressed & Z_TRIG) {
+                            play_sound(SOUND_MENU_CAMERA_BUZZ, gDefaultSoundArgs);
+                            break;
+                        }
+                        break;
+                }
+                break;
+            case LEVEL_BOB:
+                switch (SPL) {
+                    case 0:
+                        break;
+                    case 1:
+                        if (m->controller->buttonDown & L_TRIG
+                            && m->controller->buttonPressed & Z_TRIG) {
+                            spawn_object_relative(0, 0, 10, 300, gCurrentObject, MODEL_KING_BOBOMB,
+                                                  bhvKingBobomb);
+                            break;
+                        }
+                        break;
+                    case 2:
+                        if (m->controller->buttonDown & L_TRIG
+                            && m->controller->buttonPressed & Z_TRIG) {
+                            spawn_object_relative(0, 0, 100, 100, gCurrentObject,
+                                                  MODEL_KOOPA_WITH_SHELL, bhvKoopa);
+                            break;
+                        }
+                        break;
+                    case 3:
+                        if (m->controller->buttonDown & L_TRIG
+                            && m->controller->buttonPressed & Z_TRIG) {
+                            spawn_object_relative(0, 0, 10, 200, gCurrentObject, MODEL_PIRANHA_PLANT,
+                                                  bhvPiranhaPlant);
+                            break;
+                        }
+                        break;
+                    case 4:
+                        if (m->controller->buttonDown & L_TRIG
+                            && m->controller->buttonPressed & Z_TRIG) {
+                            spawn_object_relative(0, 0, 100, 100, gCurrentObject, MODEL_WHOMP,
+                                                  bhvSmallWhomp);
+                            break;
+                        }
+                        break;
+                    case 5:
+                        if (m->controller->buttonDown & L_TRIG
+                            && m->controller->buttonPressed & Z_TRIG) {
+                            spawn_object_relative(0, 0, 100, 300, gCurrentObject, MODEL_CHAIN_CHOMP,
+                                                  bhvChainChomp);
+                            break;
+                        }
+                        break;
+                    case 6:
+                    case 7:
+                        if (m->controller->buttonDown & L_TRIG
+                            && m->controller->buttonPressed & Z_TRIG) {
+                            play_sound(SOUND_MENU_CAMERA_BUZZ, gDefaultSoundArgs);
+                            break;
+                        }
+                        break;
+                }
+                break;
+            case LEVEL_BBH:
+                switch (SPL) {
+                    case 0:
+                        break;
+                    case 1:
+                        if (m->controller->buttonDown & L_TRIG
+                            && m->controller->buttonPressed & Z_TRIG) {
+                            spawn_object_relative(0, 0, 100, 100, gCurrentObject, MODEL_MAD_PIANO,
+                                                  bhvMadPiano);
+                            break;
+                        }
+                        break;
+                    case 2:
+                        if (m->controller->buttonDown & L_TRIG
+                            && m->controller->buttonPressed & Z_TRIG) {
+                            spawn_object_relative(0, 0, 100, 150, gCurrentObject, MODEL_BOO, bhvBoo);
+                            break;
+                        }
+                        break;
+                    case 3:
+                        if (m->controller->buttonDown & L_TRIG
+                            && m->controller->buttonPressed & Z_TRIG) {
+                            spawn_object_relative(0, 0, 300, 300, gCurrentObject, MODEL_SWOOP,
+                                                  bhvSwoop);
+                            break;
+                        }
+                        break;
+                    case 4:
+                        if (m->controller->buttonDown & L_TRIG
+                            && m->controller->buttonPressed & Z_TRIG) {
+                            spawn_object_relative(0, 0, 100, 200, gCurrentObject, MODEL_SNUFIT,
+                                                  bhvSnufit);
+                            break;
+                        }
+                        break;
+                    case 5:
+                        if (m->controller->buttonDown & L_TRIG
+                            && m->controller->buttonPressed & Z_TRIG) {
+                            spawn_object_relative(0, 0, 10, 200, gCurrentObject, MODEL_DORRIE,
+                                                  bhvDorrie);
+                            break;
+                        }
+                        break;
+                    case 6:
+                        if (m->controller->buttonDown & L_TRIG
+                            && m->controller->buttonPressed & Z_TRIG) {
+                            spawn_object_relative(0, 0, 100, 100, gCurrentObject, MODEL_SCUTTLEBUG,
+                                                  bhvScuttlebug);
+                            break;
+                        }
+                        break;
+                    case 7:
+                        if (m->controller->buttonDown & L_TRIG
+                            && m->controller->buttonPressed & Z_TRIG) {
+                            play_sound(SOUND_MENU_CAMERA_BUZZ, gDefaultSoundArgs);
+                            break;
+                        }
+                        break;
+                }
+                break;
+            case LEVEL_WF:
+                switch (SPL) {
+                    case 0:
+                        break;
+                    case 1:
+                        if (m->controller->buttonDown & L_TRIG
+                            && m->controller->buttonPressed & Z_TRIG) {
+                            spawn_object_relative(0, 0, 100, 150, gCurrentObject, MODEL_THWOMP,
+                                                  bhvThwomp);
+                            break;
+                        }
+                        break;
+                    case 2:
+                        if (m->controller->buttonDown & L_TRIG
+                            && m->controller->buttonPressed & Z_TRIG) {
+                            spawn_object_relative(0, 0, 300, 300, gCurrentObject, MODEL_BULLET_BILL,
+                                                  bhvBulletBill);
+                            break;
+                        }
+                        break;
+                    case 3:
+                        if (m->controller->buttonDown & L_TRIG
+                            && m->controller->buttonPressed & Z_TRIG) {
+                            spawn_object_relative(0, 0, 100, 200, gCurrentObject, MODEL_HEAVE_HO,
+                                                  bhvHeaveHo);
+                            break;
+                        }
+                        break;
+                    case 4:
+                        if (m->controller->buttonDown & L_TRIG
+                            && m->controller->buttonPressed & Z_TRIG) {
+                            spawn_object_relative(0, 0, 100, 100, gCurrentObject,
+                                                  MODEL_KOOPA_WITH_SHELL, bhvKoopa);
+                            break;
+                        }
+                        break;
+                    case 5:
+                        if (m->controller->buttonDown & L_TRIG
+                            && m->controller->buttonPressed & Z_TRIG) {
+                            spawn_object_relative(0, 0, 10, 200, gCurrentObject, MODEL_PIRANHA_PLANT,
+                                                  bhvPiranhaPlant);
+                            break;
+                        }
+                        break;
+                    case 6:
+                        if (m->controller->buttonDown & L_TRIG
+                            && m->controller->buttonPressed & Z_TRIG) {
+                            spawn_object_relative(0, 0, 100, 100, gCurrentObject, MODEL_WHOMP,
+                                                  bhvSmallWhomp);
+                            break;
+                        }
+                        break;
+                    case 7:
+                        if (m->controller->buttonDown & L_TRIG
+                            && m->controller->buttonPressed & Z_TRIG) {
+                            spawn_object_relative(0, 0, 100, 300, gCurrentObject, MODEL_CHAIN_CHOMP,
+                                                  bhvChainChomp);
+                            break;
+                        }
+                        break;
+                }
+                break;
+            case LEVEL_JRB:
+            case LEVEL_DDD:
+            case LEVEL_SA:
+                switch (SPL) {
+                    case 0:
+                        break;
+                    case 1:
+                        if (m->controller->buttonDown & L_TRIG
+                            && m->controller->buttonPressed & Z_TRIG) {
+                            spawn_object_relative(0, 0, 100, 300, gCurrentObject, MODEL_CLAM_SHELL,
+                                                  bhvClamShell);
+                            break;
+                        }
+                        break;
+                    case 2:
+                        if (m->controller->buttonDown & L_TRIG
+                            && m->controller->buttonPressed & Z_TRIG) {
+                            spawn_object_relative(0, 0, 100, 100, gCurrentObject, MODEL_MANTA_RAY,
+                                                  bhvMantaRay);
+                            break;
+                        }
+                        break;
+                    case 3:
+                        if (m->controller->buttonDown & L_TRIG
+                            && m->controller->buttonPressed & Z_TRIG) {
+                            spawn_object_relative(0, 0, 10, 100, gCurrentObject, MODEL_SUSHI,
+                                                  bhvSushiShark);
+                            break;
+                        }
+                        break;
+                    case 4:
+                        if (m->controller->buttonDown & L_TRIG
+                            && m->controller->buttonPressed & Z_TRIG) {
+                            spawn_object_relative(0, 0, 300, 300, gCurrentObject, MODEL_UNAGI,
+                                                  bhvUnagi);
+                            break;
+                        }
+                        break;
+                    case 5:
+                        if (m->controller->buttonDown & L_TRIG
+                            && m->controller->buttonPressed & Z_TRIG) {
+                            spawn_object_relative(0, 0, 100, 100, gCurrentObject, MODEL_SKEETER,
+                                                  bhvSkeeter);
+                            break;
+                        }
+                        break;
+                    case 6:
+                    case 7:
+                        if (m->controller->buttonDown & L_TRIG
+                            && m->controller->buttonPressed & Z_TRIG) {
+                            play_sound(SOUND_MENU_CAMERA_BUZZ, gDefaultSoundArgs);
+                            break;
+                        }
+                        break;
+                }
+                break;
+            case LEVEL_CCM:
+            case LEVEL_SL:
+                switch (SPL) {
+                    case 0:
+                        break;
+                    case 1:
+                        if (m->controller->buttonDown & L_TRIG
+                            && m->controller->buttonPressed & Z_TRIG) {
+                            spawn_object_relative(0, 0, 100, 100, gCurrentObject, MODEL_SPINDRIFT,
+                                                  bhvSpindrift);
+                            break;
+                        }
+                        break;
+                    case 2:
+                        if (m->controller->buttonDown & L_TRIG
+                            && m->controller->buttonPressed & Z_TRIG) {
+                            spawn_object_relative(0, 0, 100, 150, gCurrentObject, MODEL_BIG_CHILL_BULLY,
+                                                  bhvBigChillBully);
+                            break;
+                        }
+                        break;
+                    case 3:
+                        if (m->controller->buttonDown & L_TRIG
+                            && m->controller->buttonPressed & Z_TRIG) {
+                            spawn_object_relative(0, 0, 100, 200, gCurrentObject, MODEL_MONEYBAG,
+                                                  bhvMoneybag);
+                            break;
+                        }
+                        break;
+                    case 4:
+                    case 5:
+                    case 6:
+                    case 7:
+                        if (m->controller->buttonDown & L_TRIG
+                            && m->controller->buttonPressed & Z_TRIG) {
+                            play_sound(SOUND_MENU_CAMERA_BUZZ, gDefaultSoundArgs);
+                            break;
+                        }
+                        break;
+                }
+                break;
+            case LEVEL_HMC:
+                switch (SPL) {
+                    case 0:
+                        break;
+                    case 1:
+                        if (m->controller->buttonDown & L_TRIG
+                            && m->controller->buttonPressed & Z_TRIG) {
+                            spawn_object_relative(0, 0, 50, 100, gCurrentObject, MODEL_MONTY_MOLE,
+                                                  bhvMontyMole);
+                            break;
+                        }
+                        break;
+                    case 2:
+                        if (m->controller->buttonDown & L_TRIG
+                            && m->controller->buttonPressed & Z_TRIG) {
+                            spawn_object_relative(0, 0, 100, 200, gCurrentObject, MODEL_UKIKI,
+                                                  bhvUkiki);
+                            break;
+                        }
+                        break;
+                    case 3:
+                        if (m->controller->buttonDown & L_TRIG
+                            && m->controller->buttonPressed & Z_TRIG) {
+                            spawn_object_relative(0, 0, 300, 300, gCurrentObject, MODEL_SWOOP,
+                                                  bhvSwoop);
+                            break;
+                        }
+                        break;
+                    case 4:
+                        if (m->controller->buttonDown & L_TRIG
+                            && m->controller->buttonPressed & Z_TRIG) {
+                            spawn_object_relative(0, 0, 100, 200, gCurrentObject, MODEL_SNUFIT,
+                                                  bhvSnufit);
+                            break;
+                        }
+                        break;
+                    case 5:
+                        if (m->controller->buttonDown & L_TRIG
+                            && m->controller->buttonPressed & Z_TRIG) {
+                            spawn_object_relative(0, 0, 10, 200, gCurrentObject, MODEL_DORRIE,
+                                                  bhvDorrie);
+                            break;
+                        }
+                        break;
+                    case 6:
+                        if (m->controller->buttonDown & L_TRIG
+                            && m->controller->buttonPressed & Z_TRIG) {
+                            spawn_object_relative(0, 0, 100, 100, gCurrentObject, MODEL_SCUTTLEBUG,
+                                                  bhvScuttlebug);
+                            break;
+                        }
+                        break;
+                    case 7:
+                        if (m->controller->buttonDown & L_TRIG
+                            && m->controller->buttonPressed & Z_TRIG) {
+                            play_sound(SOUND_MENU_CAMERA_BUZZ, gDefaultSoundArgs);
+                            break;
+                        }
+                        break;
+                }
+                break;
+            case LEVEL_SSL:
+                switch (SPL) {
+                    case 0:
+                        break;
+                    case 1:
+                        if (m->controller->buttonDown & L_TRIG
+                            && m->controller->buttonPressed & Z_TRIG) {
+                            spawn_object_relative(0, 0, 100, 200, gCurrentObject, MODEL_POKEY_HEAD,
+                                                  bhvPokey);
+                            break;
+                        }
+                        break;
+                    case 2:
+                        if (m->controller->buttonDown & L_TRIG
+                            && m->controller->buttonPressed & Z_TRIG) {
+                            spawn_object_relative(0, 0, 300, 300, gCurrentObject, MODEL_KLEPTO,
+                                                  bhvKlepto);
+                            break;
+                        }
+                        break;
+                    case 3:
+                    case 4:
+                    case 5:
+                    case 6:
+                    case 7:
+                        if (m->controller->buttonDown & L_TRIG
+                            && m->controller->buttonPressed & Z_TRIG) {
+                            play_sound(SOUND_MENU_CAMERA_BUZZ, gDefaultSoundArgs);
+                            break;
+                        }
+                        break;
+                }
+                break;
+            case LEVEL_WDW:
+                switch (SPL) {
+                    case 0:
+                        break;
+                    case 1:
+                        if (m->controller->buttonDown & L_TRIG
+                            && m->controller->buttonPressed & Z_TRIG) {
+                            spawn_object_relative(0, 0, 100, 150, gCurrentObject, MODEL_THWOMP,
+                                                  bhvThwomp);
+                            break;
+                        }
+                        break;
+                    case 2:
+                        if (m->controller->buttonDown & L_TRIG
+                            && m->controller->buttonPressed & Z_TRIG) {
+                            spawn_object_relative(0, 0, 300, 300, gCurrentObject, MODEL_BULLET_BILL,
+                                                  bhvBulletBill);
+                            break;
+                        }
+                        break;
+                    case 3:
+                        if (m->controller->buttonDown & L_TRIG
+                            && m->controller->buttonPressed & Z_TRIG) {
+                            spawn_object_relative(0, 0, 100, 200, gCurrentObject, MODEL_HEAVE_HO,
+                                                  bhvHeaveHo);
+                            break;
+                        }
+                        break;
+                    case 4:
+                        if (m->controller->buttonDown & L_TRIG
+                            && m->controller->buttonPressed & Z_TRIG) {
+                            spawn_object_relative(0, 0, 100, 100, gCurrentObject, MODEL_SKEETER,
+                                                  bhvSkeeter);
+                            break;
+                        }
+                        break;
+                    case 5:
+                    case 6:
+                    case 7:
+                        if (m->controller->buttonDown & L_TRIG
+                            && m->controller->buttonPressed & Z_TRIG) {
+                            play_sound(SOUND_MENU_CAMERA_BUZZ, gDefaultSoundArgs);
+                            break;
+                        }
+                        break;
+                }
+                break;
+            case LEVEL_TTM:
+                switch (SPL) {
+                    case 0:
+                        break;
+                    case 1:
+                        if (m->controller->buttonDown & L_TRIG
+                            && m->controller->buttonPressed & Z_TRIG) {
+                            spawn_object_relative(0, 0, 100, 100, gCurrentObject, MODEL_MONTY_MOLE,
+                                                  bhvMontyMole);
+                            break;
+                        }
+                        break;
+                    case 2:
+                        if (m->controller->buttonDown & L_TRIG
+                            && m->controller->buttonPressed & Z_TRIG) {
+                            spawn_object_relative(0, 0, 100, 200, gCurrentObject, MODEL_UKIKI,
+                                                  bhvUkiki);
+                            break;
+                        }
+                        break;
+                    case 3:
+                    case 4:
+                    case 5:
+                    case 6:
+                    case 7:
+                        if (m->controller->buttonDown & L_TRIG
+                            && m->controller->buttonPressed & Z_TRIG) {
+                            play_sound(SOUND_MENU_CAMERA_BUZZ, gDefaultSoundArgs);
+                            break;
+                        }
+                        break;
+                }
+                break;
+            case LEVEL_THI:
+                switch (SPL) {
+                    case 0:
+                        break;
+                    case 1:
+                        if (m->controller->buttonDown & L_TRIG
+                            && m->controller->buttonPressed & Z_TRIG) {
+                            spawn_object_relative(0, 0, 100, 100, gCurrentObject, MODEL_BUBBA,
+                                                  bhvBubba);
+                            break;
+                        }
+                        break;
+                    case 2:
+                        if (m->controller->buttonDown & L_TRIG
+                            && m->controller->buttonPressed & Z_TRIG) {
+                            spawn_object_relative(0, 0, 100, 150, gCurrentObject, MODEL_ENEMY_LAKITU,
+                                                  bhvEnemyLakitu);
+                            break;
+                        }
+                        break;
+                    case 3:
+                        if (m->controller->buttonDown & L_TRIG
+                            && m->controller->buttonPressed & Z_TRIG) {
+                            spawn_object_relative(0, 0, 100, 100, gCurrentObject,
+                                                  MODEL_KOOPA_WITH_SHELL, bhvKoopa);
+                            break;
+                        }
+                        break;
+                    case 4:
+                        if (m->controller->buttonDown & L_TRIG
+                            && m->controller->buttonPressed & Z_TRIG) {
+                            spawn_object_relative(0, 0, 10, 200, gCurrentObject, MODEL_PIRANHA_PLANT,
+                                                  bhvPiranhaPlant);
+                            break;
+                        }
+                        break;
+                    case 5:
+                        if (m->controller->buttonDown & L_TRIG
+                            && m->controller->buttonPressed & Z_TRIG) {
+                            spawn_object_relative(0, 0, 100, 100, gCurrentObject, MODEL_WHOMP,
+                                                  bhvSmallWhomp);
+                            break;
+                        }
+                        break;
+                    case 6:
+                        if (m->controller->buttonDown & L_TRIG
+                            && m->controller->buttonPressed & Z_TRIG) {
+                            spawn_object_relative(0, 0, 100, 300, gCurrentObject, MODEL_CHAIN_CHOMP,
+                                                  bhvChainChomp);
+                            break;
+                        }
+                        break;
+                    case 7:
+                        if (m->controller->buttonDown & L_TRIG
+                            && m->controller->buttonPressed & Z_TRIG) {
+                            play_sound(SOUND_MENU_CAMERA_BUZZ, gDefaultSoundArgs);
+                            break;
+                        }
+                        break;
+                }
+                break;
+            case LEVEL_TTC:
+                switch (SPL) {
+                    case 0:
+                        break;
+                    case 1:
+                        if (m->controller->buttonDown & L_TRIG
+                            && m->controller->buttonPressed & Z_TRIG) {
+                            spawn_object_relative(0, 0, 100, 150, gCurrentObject, MODEL_THWOMP,
+                                                  bhvThwomp);
+                            break;
+                        }
+                        break;
+                    case 2:
+                        if (m->controller->buttonDown & L_TRIG
+                            && m->controller->buttonPressed & Z_TRIG) {
+                            spawn_object_relative(0, 0, 300, 300, gCurrentObject, MODEL_BULLET_BILL,
+                                                  bhvBulletBill);
+                            break;
+                        }
+                        break;
+                    case 3:
+                        if (m->controller->buttonDown & L_TRIG
+                            && m->controller->buttonPressed & Z_TRIG) {
+                            spawn_object_relative(0, 0, 100, 200, gCurrentObject, MODEL_HEAVE_HO,
+                                                  bhvHeaveHo);
+                            break;
+                        }
+                        break;
+                    case 4:
+                    case 5:
+                    case 6:
+                    case 7:
+                        if (m->controller->buttonDown & L_TRIG
+                            && m->controller->buttonPressed & Z_TRIG) {
+                            play_sound(SOUND_MENU_CAMERA_BUZZ, gDefaultSoundArgs);
+                            break;
+                        }
+                        break;
+                }
+                break;
+            case LEVEL_RR:
+                switch (SPL) {
+                    case 0:
+                        break;
+                    case 1:
+                        if (m->controller->buttonDown & L_TRIG
+                            && m->controller->buttonPressed & Z_TRIG) {
+                            spawn_object_relative(0, 0, 100, 100, gCurrentObject, MODEL_BUBBA,
+                                                  bhvBubba);
+                            break;
+                        }
+                        break;
+                    case 2:
+                        if (m->controller->buttonDown & L_TRIG
+                            && m->controller->buttonPressed & Z_TRIG) {
+                            spawn_object_relative(0, 0, 100, 150, gCurrentObject, MODEL_ENEMY_LAKITU,
+                                                  bhvEnemyLakitu);
+                            break;
+                        }
+                        break;
+                    case 3:
+                    case 4:
+                    case 5:
+                    case 6:
+                    case 7:
+                        if (m->controller->buttonDown & L_TRIG
+                            && m->controller->buttonPressed & Z_TRIG) {
+                            play_sound(SOUND_MENU_CAMERA_BUZZ, gDefaultSoundArgs);
+                            break;
+                        }
+                        break;
+                }
+                break;
+            case LEVEL_COTMC:
+                switch (SPL) {
+                    case 0:
+                        break;
+                    case 1:
+                        if (m->controller->buttonDown & L_TRIG
+                            && m->controller->buttonPressed & Z_TRIG) {
+                            spawn_object_relative(0, 0, 300, 300, gCurrentObject, MODEL_SWOOP,
+                                                  bhvSwoop);
+                            break;
+                        }
+                        break;
+                    case 2:
+                        if (m->controller->buttonDown & L_TRIG
+                            && m->controller->buttonPressed & Z_TRIG) {
+                            spawn_object_relative(0, 0, 100, 200, gCurrentObject, MODEL_SNUFIT,
+                                                  bhvSnufit);
+                            break;
+                        }
+                        break;
+                    case 3:
+                        if (m->controller->buttonDown & L_TRIG
+                            && m->controller->buttonPressed & Z_TRIG) {
+                            spawn_object_relative(0, 0, 10, 200, gCurrentObject, MODEL_DORRIE,
+                                                  bhvDorrie);
+                            break;
+                        }
+                        break;
+                    case 4:
+                        if (m->controller->buttonDown & L_TRIG
+                            && m->controller->buttonPressed & Z_TRIG) {
+                            spawn_object_relative(0, 0, 100, 100, gCurrentObject, MODEL_SCUTTLEBUG,
+                                                  bhvScuttlebug);
+                            break;
+                        }
+                        break;
+                    case 5:
+                    case 6:
+                    case 7:
+                        if (m->controller->buttonDown & L_TRIG
+                            && m->controller->buttonPressed & Z_TRIG) {
+                            play_sound(SOUND_MENU_CAMERA_BUZZ, gDefaultSoundArgs);
+                            break;
+                        }
+                        break;
+                }
+                break;
+        }
+
+        /*Drain JRB?*/
+        f32 watLev;
+        watLev -= 800;
+        if (WAT_CON == 1) {
+            watLev += WAT_LEV * 100;
+        }
+        if (WAT_CON == 1 && gCurrLevelNum == LEVEL_JRB) {
+            gEnvironmentRegions[6] = approach_f32_symmetric(gEnvironmentRegions[6], watLev * 10, 10.0f);
+            gEnvironmentRegions[12] = approach_f32_symmetric(gEnvironmentRegions[12], watLev * 10, 10.0f);
+        }
+
+        /*Coin Magnet*/
+        struct Object* coinMag = cur_obj_nearest_object_with_behavior(bhvYellowCoin);
+        struct Object* coinMagMove = cur_obj_nearest_object_with_behavior(bhvMovingYellowCoin);
+        f32 oDist;
+        f32 oDistMove;
+        if (coinMag != NULL && m->marioObj != NULL) {
+            oDist = dist_between_objects(coinMag, m->marioObj);
+        }
+        if (coinMagMove != NULL && m->marioObj != NULL) {
+            oDistMove = dist_between_objects(coinMagMove, m->marioObj);
+        }
+        while (COIN_MAG == 1 && oDist != 0 && oDist >= 100 && oDist < 1000) {
+            while (oDist >= 10) {
+                coinMag->oPosX = approach_f32_symmetric(coinMag->oPosX, m->pos[0], 28);
+                coinMag->oPosY = approach_f32_symmetric(coinMag->oPosY, m->pos[1], 28);
+                coinMag->oPosZ = approach_f32_symmetric(coinMag->oPosZ, m->pos[2], 28);
+                break;
+            }
+            break;
+        }
+        if (oDist == 0 && oDist > 1000) {
+            obj_mark_for_deletion(coinMag);
+            break;
+        }
+        while (COIN_MAG == 1 && coinMagMove != NULL && oDistMove >= 100 && oDistMove < 1000) {
+            while (oDistMove >= 10) {
+                coinMagMove->oPosX = approach_f32_symmetric(coinMagMove->oPosX, m->pos[0], 28);
+                coinMagMove->oPosY = approach_f32_symmetric(coinMagMove->oPosY, m->pos[1], 28);
+                coinMagMove->oPosZ = approach_f32_symmetric(coinMagMove->oPosZ, m->pos[2], 28);
+                break;
+            }
+            break;
+        }
+        if (oDistMove == 0 && oDistMove > 1000) {
+            obj_mark_for_deletion(coinMagMove);
+            break;
+        }
+
+        /*Swim Anywhere*/
+        if (SWIM_ANY == 1) {
+            set_submerged_cam_preset_and_spawn_bubbles(m);
+            m->waterLevel = m->pos[1] + 300;
+        }
+
+        /*No Hold Heavy*/
+        if (NO_HEAVY == 1) {
+            while ((m->action & ACT_GROUP_MASK) == ACT_GROUP_MOVING) {
+                if (m->action == ACT_HOLD_HEAVY_WALKING) {
+                    set_mario_action(m, ACT_HOLD_WALKING, 0);
+                    break;
+                }
+                break;
+            }
+        }
+
+        /*CHAOS Mode*/
+        if (CHAOS_MODE == 1) {
+            srand(time(NULL));
+            r = rand();
+
+            switch ((rand() % 30)) {
+                case 0:
+                    if (Cheats.Run <= 3) {
+                        Cheats.Run += 1;
+                    } else if (Cheats.Run >= 4) {
+                        Cheats.Run = 0;
+                    }
+                    break;
+                case 1:
+                    if (Cheats.HugeMario == true) {
+                        Cheats.HugeMario = false;
+                    } else {
+                        Cheats.HugeMario = true;
+                    }
+                    break;
+                case 2:
+                    if (Cheats.TinyMario == true) {
+                        Cheats.TinyMario = false;
+                    } else {
+                        Cheats.TinyMario = true;
+                    }
+                    break;
+                case 3:
+                    if (Cheats.Moon == true) {
+                        Cheats.Moon = false;
+                    } else {
+                        Cheats.Moon = true;
+                    }
+                    break;
+                case 4:
+                    if (Cheats.Jump == true) {
+                        Cheats.Jump = false;
+                    } else {
+                        Cheats.Jump = true;
+                    }
+                    break;
+                case 5:
+                    play_transition(WARP_TRANSITION_FADE_FROM_COLOR, 0x3C, 0xFF, 0xFF, 0xFF);
+                    break;
+                case 6:
+                    if (Cheats.Triple == true) {
+                        Cheats.Triple = false;
+                    } else {
+                        Cheats.Triple = true;
+                    }
+                    break;
+                case 7:
+                    obj_spawn_yellow_coins(m->marioObj, 1);
+                    break;
+                case 8:
+                    if (Cheats.PAC <= 6) {
+                        Cheats.PAC += 1;
+                    } else if (Cheats.PAC >= 7) {
+                        Cheats.PAC = 0;
+                    }
+                    break;
+                case 9:
+                    hurt_and_set_mario_action(m, ACT_FORWARD_AIR_KB, 0, 0);
+                    break;
+                case 10:
+                    cur_obj_shake_screen(SHAKE_POS_SMALL);
+                    break;
+                case 11:
+                    m->forwardVel = (m->forwardVel + 5.0f);
+                    break;
+                case 12:
+                    m->vel[1] -= 5;
+                    break;
+                case 13:
+                    // Empty Slot
+                    break;
+                case 14:
+                    // Empty Slot
+                    break;
+                case 15:
+                    // Empty Slot
+                    break;
+                case 16:
+                case 17:
+                    while (1) {
+                        print_text_fmt_int(90, 70, "CH3 %d 4T3R", m->forwardVel);
+                        break;
+                    }
+                    break;
+                case 18:
+                case 19:
+                    while (1) {
+                        print_text_fmt_int(90, 70, "%d CHEATER %d", m->forwardVel);
+                        break;
+                    }
+                    break;
+                case 20:
+                case 21:
+                case 22:
+                case 23:
+                case 24:
+                case 25:
+                case 26:
+                case 27:
+                case 28:
+                case 29:
+                case 30:
+                    while (1) {
+                        print_text(240, 92, " ");
+                        break;
+                    }
+                    break;
+            }
+        }
+
+        /*Time Stop Cheat*/
+        if (Cheats.TimeStop) {
+            enable_time_stop();
+        }
+        if (!Cheats.TimeStop) {
+            gTimeStopState &= ~(TIME_STOP_ENABLED);
+        }
+        /* Time Stop DynOS emhancements*/
+        if (Cheats.TimeSlow && Cheats.TimeStop == false && !(m->controller->buttonDown & TIME_BUTTON)) {
+            Cheats.TimeStop = true;
+        }
+        if (Cheats.TimeSlow == false && Cheats.TimeStop && !(m->controller->buttonDown & TIME_BUTTON)) {
+            Cheats.TimeStop = false;
+        }
+        if (m->controller->buttonDown & TIME_BUTTON) {
+            if (!Cheats.TimeSlow) {
+                Cheats.TimeSlow = true;
+            } else
+            if (Cheats.TimeSlow) {
+                Cheats.TimeSlow = false;
+            }
+        }
+
+
+        /*FLYER Cheat*/
+        if (Cheats.Fly) {
+            if (m->action == ACT_FLYING) {
+                if (m->controller->buttonDown & A_BUTTON) {
+                    m->particleFlags |= PARTICLE_SPARKLES;
+                }
+            }
+        }
+
+        /*Coin Spawner*/
+        switch (Cheats.Coin) {
+            case 0:
+                break;
+            case 1:
+                if (m->controller->buttonDown & B_BUTTON) {
+                    obj_spawn_yellow_coins(m->marioObj, 1);
+                    break;
+                }
+                break;
+            case 2:
+                if (m->controller->buttonDown & B_BUTTON) {
+                    spawn_object(m->marioObj, MODEL_BLUE_COIN, bhvBlueCoinJumping);
+                    break;
+                }
+                break;
+            case 3:
+                if (m->controller->buttonDown & B_BUTTON) {
+                    spawn_object_relative(0, 0, 70, 150, m->marioObj, MODEL_RED_COIN, bhvRedCoin);
+                    break;
+                }
+                break;
+        }
+
+        /*All Jumps Triple Cheat*/
+        while (Cheats.Triple && (m->action & ACT_GROUP_MASK) != ACT_GROUP_SUBMERGED) {
+            // While Triple Jump Cheat is true and Mario's is not underwater
+            if (m->controller->buttonPressed & A_BUTTON && m->action != ACT_TRIPLE_JUMP) {
+                // If A is pressed and not already triple jumping
+                set_mario_action(m, ACT_TRIPLE_JUMP, 0);
+                // Break out of the while
+                break;
+            }
+            // Break out of the while
+            break;
+        }
+
+        /*Hover Cheat*/
+        if (Cheats.Hover) {
+            set_mario_action(m, ACT_DEBUG_FREE_MOVE, 0);
+            Cheats.Hover = false;
+        }
+
+        /*Moon Gravity*/
+        while (Cheats.Moon) {
+            while ((m->action & ACT_GROUP_MASK) == ACT_GROUP_AIRBORNE) {
+                if (m->action != ACT_FREEFALL && m->action != ACT_LONG_JUMP) {
+                    m->vel[1] += 2;
+                    break;
+                } else {
+                    m->vel[1] += 1;
+                    break;
+                }
+                break;
+            }
+            break;
+        }
+        /*Jump Modifier*/
+        while (Cheats.Jump) {
+            while ((m->action & ACT_GROUP_MASK) == ACT_GROUP_AIRBORNE) {
+                if (m->action != ACT_FREEFALL) {
+                    m->vel[1] += 1;
+                    break;
+                }
+                if (m->action &= ACT_FREEFALL) {
+                    m->vel[1] -= 5;
+                    break;
+                }
+                break;
+            }
+            break;
+        }
+
+        /*Run Modifier Cheat*/
+        switch (Cheats.Run) {
+            case 0:
+                break;
+            case 1:
+                if (m->action == ACT_WALKING && m->forwardVel >= 0) {
+                    m->forwardVel = (m->forwardVel - 0.5f);
+                }
+                break;
+            case 2:
+                if (m->action == ACT_WALKING && m->forwardVel >= 0) {
+                    m->forwardVel = (m->forwardVel - 0.7f);
+                }
+                break;
+            case 3:
+                if (m->action == ACT_WALKING && m->forwardVel >= 0) {
+                    m->forwardVel = (m->forwardVel * 1.2f);
+                }
+                break;
+            case 4:
+                if (m->action == ACT_WALKING && m->forwardVel >= 0) {
+                    m->forwardVel = (m->forwardVel * 1.8f);
+                }
+                break;
+        }
+        /*Play As Cheat*/
+        switch(Cheats.PAC) {
+            /*Model Choices*/
+            case 0:
+#ifdef R96
+                m->marioObj->header.gfx.sharedChild = gLoadedGraphNodes[MODEL_PLAYER];
+                if (isLuigi() == 1) {
+                    gMarioState->animation = &Data_LuigiAnims;
+                } else {
+                    gMarioState->animation = &D_80339D10;
+                }
+                break;
+#else
+                m->marioObj->header.gfx.sharedChild = gLoadedGraphNodes[MODEL_MARIO]; //Use MODEL_PLAYER
+                m->animation = &D_80339D10; //Only Mario's animations
+                break;
+#endif // R96
+            case 1:
+                m->marioObj->header.gfx.sharedChild = gLoadedGraphNodes[MODEL_BLACK_BOBOMB];
+                m->marioObj->header.gfx.unk38.curAnim = bobomb_seg8_anims_0802396C[0];
+                break;
+            case 2:
+                m->marioObj->header.gfx.sharedChild = gLoadedGraphNodes[MODEL_BOBOMB_BUDDY];
+                m->marioObj->header.gfx.unk38.curAnim = bobomb_seg8_anims_0802396C[0];
+                break;
+            case 3:
+                m->marioObj->header.gfx.sharedChild = gLoadedGraphNodes[MODEL_GOOMBA];
+                m->marioObj->header.gfx.unk38.curAnim = goomba_seg8_anims_0801DA4C[0];
+                break;
+            case 4:
+                m->marioObj->header.gfx.sharedChild = gLoadedGraphNodes[MODEL_KOOPA_SHELL];
+                m->marioObj->header.gfx.unk38.curAnim = amp_seg8_anims_08004034[0];
+                break;
+            case 5:
+                m->marioObj->header.gfx.sharedChild = gLoadedGraphNodes[MODEL_CHUCKYA];
+                m->marioObj->header.gfx.unk38.curAnim = chuckya_seg8_anims_0800C070[0];
+                break; //Forgot this in v7
+            case 6:
+                m->marioObj->header.gfx.sharedChild = gLoadedGraphNodes[MODEL_FLYGUY];
+                m->marioObj->header.gfx.unk38.curAnim = flyguy_seg8_anims_08011A64[0];
+                break;
+            case 7:
+                switch (gCurrLevelNum) {
+                    case LEVEL_CASTLE_GROUNDS:
+                        m->marioObj->header.gfx.sharedChild = gLoadedGraphNodes[MODEL_YOSHI];
+                        m->marioObj->header.gfx.unk38.curAnim = yoshi_seg5_anims_05024100[0];
+                        break;
+                    case LEVEL_BOB:
+                        m->marioObj->header.gfx.sharedChild = gLoadedGraphNodes[MODEL_KOOPA_WITH_SHELL];
+                        m->marioObj->header.gfx.unk38.curAnim = koopa_seg6_anims_06011364[0];
+                        m->marioObj->header.gfx.unk38.animFrame += 1;
+                        break;
+                    case LEVEL_BBH:
+                        m->marioObj->header.gfx.sharedChild = gLoadedGraphNodes[MODEL_MAD_PIANO];
+                        m->marioObj->header.gfx.unk38.curAnim = mad_piano_seg5_anims_05009B14[0];
+                        break;
+                    case LEVEL_WF:
+                        m->marioObj->header.gfx.sharedChild = gLoadedGraphNodes[MODEL_WHOMP];
+                        m->marioObj->header.gfx.unk38.curAnim = whomp_seg6_anims_06020A04[0];
+                        break;
+                    case LEVEL_JRB:
+                        m->marioObj->header.gfx.sharedChild = gLoadedGraphNodes[MODEL_CLAM_SHELL];
+                        m->marioObj->header.gfx.unk38.curAnim = clam_shell_seg5_anims_05001744[0];
+                        break;
+                    case LEVEL_CCM:
+                        m->marioObj->header.gfx.sharedChild = gLoadedGraphNodes[MODEL_PENGUIN];
+                        m->marioObj->header.gfx.unk38.curAnim = penguin_seg5_anims_05008B74[0];
+                        break;
+                    case LEVEL_PSS:
+                        m->marioObj->header.gfx.sharedChild = gLoadedGraphNodes[MODEL_WOODEN_SIGNPOST];
+                        break;
+                    case LEVEL_HMC:
+                        m->marioObj->header.gfx.sharedChild = gLoadedGraphNodes[MODEL_HMC_ROLLING_ROCK];
+                        break;
+                    case LEVEL_LLL:
+                        m->marioObj->header.gfx.sharedChild = gLoadedGraphNodes[MODEL_BULLY];
+                        m->marioObj->header.gfx.unk38.curAnim = bully_seg5_anims_0500470C[0];
+                        break;
+                    case LEVEL_SSL:
+                        m->marioObj->header.gfx.sharedChild = gLoadedGraphNodes[MODEL_KLEPTO];
+                        m->marioObj->header.gfx.unk38.curAnim = klepto_seg5_anims_05008CFC[0];
+                        break;
+                    case LEVEL_DDD:
+                        m->marioObj->header.gfx.sharedChild = gLoadedGraphNodes[MODEL_SUSHI];
+                        m->marioObj->header.gfx.unk38.curAnim = sushi_seg5_anims_0500AE54[0];
+                        break;
+                    case LEVEL_SL:
+                        m->marioObj->header.gfx.sharedChild = gLoadedGraphNodes[MODEL_SPINDRIFT];
+                        m->marioObj->header.gfx.unk38.curAnim = spindrift_seg5_anims_05002D68[0];
+                        break;
+                    case LEVEL_WDW:
+                        m->marioObj->header.gfx.sharedChild = gLoadedGraphNodes[MODEL_SKEETER];
+                        m->marioObj->header.gfx.unk38.curAnim = skeeter_seg6_anims_06007DE0[0];
+                        break;
+                    case LEVEL_TTM:
+                        m->marioObj->header.gfx.sharedChild = gLoadedGraphNodes[MODEL_UKIKI];
+                        m->marioObj->header.gfx.unk38.curAnim = ukiki_seg5_anims_05015784[0];
+                        break;
+                    case LEVEL_THI:
+                        m->marioObj->header.gfx.sharedChild = gLoadedGraphNodes[MODEL_SPINY];
+                        m->marioObj->header.gfx.unk38.curAnim = spiny_seg5_anims_05016EAC[0];
+                        break;
+                    case LEVEL_TTC:
+                        m->marioObj->header.gfx.sharedChild = gLoadedGraphNodes[MODEL_THWOMP];
+                        break;
+                    case LEVEL_RR:
+                        m->marioObj->header.gfx.sharedChild = gLoadedGraphNodes[MODEL_ENEMY_LAKITU];
+                        m->marioObj->header.gfx.unk38.curAnim = lakitu_enemy_seg5_anims_050144D4[0];
+                        break;
+                    case LEVEL_SA:
+                        m->marioObj->header.gfx.sharedChild = gLoadedGraphNodes[MODEL_MANTA_RAY];
+                        m->marioObj->header.gfx.unk38.curAnim = manta_seg5_anims_05008EB4[0];
+                        break;
+                    case LEVEL_COTMC:
+                        m->marioObj->header.gfx.sharedChild = gLoadedGraphNodes[MODEL_SNUFIT];
+                        break;
+                }
+            }
+        while (Cheats.PAC > 0) {
+            /*stops softlock when dying as a Play As Character*/
+            if (m->action == ACT_STANDING_DEATH) {
+                level_trigger_warp(m, WARP_OP_DEATH);
+                m->numLives += 1;
+                update_mario_health(m);
+                break;
+            }
+            /*Instead of making a custom hitbox for each character,
+            I neutralized the only consistent problem, doors*/
+            while (m->collidedObjInteractTypes & INTERACT_DOOR) {
+                obj_mark_for_deletion(m->usedObj);
+                spawn_object(gCurrentObject, MODEL_SMOKE, bhvBobombBullyDeathSmoke);
+                obj_scale(gCurrentObject, gCurrentObject->oTimer / 4.f + 1.0f);
+                gCurrentObject->oOpacity -= 14;
+                gCurrentObject->oAnimState++;
+                play_sound(SOUND_GENERAL2_BOBOMB_EXPLOSION, m->marioObj->header.gfx.cameraToObject);
+                m->particleFlags |= PARTICLE_TRIANGLE;
+                obj_set_pos(m->marioObj, 0, 0, 100);
+                break;
+            }
+            break;
+        }
+
+
+        /*Speed Display*/
+        if (Cheats.SPD == true) {
+            print_text_fmt_int(210, 72, "SPD %d", m->forwardVel);
+        }
+
+        /*T Pose Float? Actually it's just twirling + MoonJump*/
+        while (Cheats.TPF == true) {
+            if (m->controller->buttonDown & A_BUTTON) {
+                m->vel[1] = 25;
+                set_mario_action(m, ACT_TWIRLING, 0);
+            }
+            break;
+        }
+
+        /*QuickEnding cheat*/
+        while (Cheats.QuikEnd == true) {
+            if (m->numStars == 120) {
+                level_trigger_warp(m, WARP_OP_CREDITS_START);
+                Cheats.QuikEnd = false;
+                save_file_do_save(gCurrSaveFileNum - 1);
+            }
+            break;
+        }
+
+        /*AutoWallKick cheat*/
+        if (Cheats.AutoWK == true && m->action == ACT_AIR_HIT_WALL) {
+            m->vel[1] = 52.0f;
+            m->faceAngle[1] += 0x8000;
+            set_mario_action(m, ACT_WALL_KICK_AIR, 0);
+            m->wallKickTimer = 0;
+            set_mario_animation(m, MARIO_ANIM_START_WALLKICK);
+        }
+
+        /*HurtMario cheat*/
+        while (Cheats.Hurt > 0 && m->controller->buttonDown & L_TRIG
+               && m->controller->buttonPressed & A_BUTTON) {
+            if (Cheats.Hurt == 1) {
+                act_burning_ground(m);
+            }
+            if (Cheats.Hurt == 2) {
+                m->flags |= MARIO_METAL_SHOCK;
+                drop_and_set_mario_action(m, ACT_SHOCKED, 0);
+            }
+            if (Cheats.Hurt == 3) {
+                hurt_and_set_mario_action(m, ACT_GROUND_BONK, 0, 1);
+                play_sound(SOUND_MARIO_OOOF, m->marioObj->header.gfx.cameraToObject);
+                queue_rumble_data(5, 80);
+            }
+            break;
+        }
+
+        /*CannonAnywhere cheat*/
+        if (Cheats.Cann == true && m->controller->buttonDown & L_TRIG
+            && m->controller->buttonPressed & U_CBUTTONS) {
+            spawn_object_relative(1, 0, 200, 0, gCurrentObject, MODEL_NONE, bhvCannon);
+        }
+
+        /*InstantDeath cheat*/
+        if (m->controller->buttonDown & L_TRIG && m->controller->buttonDown & A_BUTTON
+            && m->controller->buttonPressed & B_BUTTON && m->controller->buttonDown & Z_TRIG) {
+            level_trigger_warp(m, WARP_OP_DEATH);
+            break;
+        }
+
+        /*CAP Cheats, this whole thing needs to be refactored, but
+        I've only been adding to JAGSTAX's original patch*/
+        if (Cheats.EnableCheats) {
+            if (Cheats.WingCap) {
+                m->flags |= MARIO_WING_CAP;
+                if ((m->action & ACT_GROUP_MASK) == (!(ACT_GROUP_AIRBORNE) && !(ACT_GROUP_SUBMERGED))) {
+                    set_mario_action(m, ACT_PUTTING_ON_CAP, 0);
+                }
+                play_cap_music(SEQ_EVENT_POWERUP);
+                Cheats.WingCap = false;
+            }
+
+            if (Cheats.MetalCap) {
+                m->flags |= MARIO_METAL_CAP;
+                if ((m->action & ACT_GROUP_MASK) == (!(ACT_GROUP_AIRBORNE) && !(ACT_GROUP_SUBMERGED))) {
+                    set_mario_action(m, ACT_PUTTING_ON_CAP, 0);
+                }
+                play_cap_music(SEQ_EVENT_METAL_CAP);
+                Cheats.MetalCap = false;
+            }
+
+            if (Cheats.VanishCap) {
+                m->flags |= MARIO_VANISH_CAP;
+                if ((m->action & ACT_GROUP_MASK) == (!(ACT_GROUP_AIRBORNE) && !(ACT_GROUP_SUBMERGED))) {
+                    set_mario_action(m, ACT_PUTTING_ON_CAP, 0);
+                }
+                play_cap_music(SEQ_EVENT_POWERUP);
+                Cheats.VanishCap = false;
+            }
+
+            if (Cheats.RemoveCap) {
+                m->flags &= ~MARIO_CAP_ON_HEAD;
+                m->flags |= MARIO_CAP_IN_HAND;
+                if ((m->action & ACT_GROUP_MASK) == (!(ACT_GROUP_AIRBORNE) && !(ACT_GROUP_SUBMERGED))) {
+                    set_mario_action(m, ACT_SHIVERING, 0);
+                }
+                Cheats.RemoveCap = false;
+            }
+
+            if (Cheats.NormalCap) {
+                m->flags &= ~MARIO_CAP_ON_HEAD;
+                m->flags &= ~(MARIO_WING_CAP | MARIO_METAL_CAP | MARIO_VANISH_CAP);
+                if ((m->action & ACT_GROUP_MASK) == (!(ACT_GROUP_AIRBORNE) && !(ACT_GROUP_SUBMERGED))) {
+                    m->flags |= MARIO_CAP_IN_HAND;
+                    set_mario_action(m, ACT_PUTTING_ON_CAP, 0);
+                } else {
+                    m->flags &= ~MARIO_CAP_IN_HAND;
+                    m->flags |= MARIO_CAP_ON_HEAD;
+                }
+                stop_cap_music();
+                Cheats.NormalCap = false;
+            }
+        }
+
+        /* GetShell cheat */
+        while (Cheats.GetShell == true && m->controller->buttonDown & L_TRIG
+               && m->controller->buttonPressed & R_TRIG) {
+            if (m->action & ACT_FLAG_RIDING_SHELL) {
+                break;
+            }
+
+            /*This check should be added when creating a spawn cheat to prevent spamming*/
+            struct Object *obj = (struct Object *) gObjectLists[OBJ_LIST_LEVEL].next;
+            struct Object *first = (struct Object *) &gObjectLists[OBJ_LIST_LEVEL];
+            while (obj != NULL && obj != first) {
+                if (obj->header.gfx.sharedChild = gLoadedGraphNodes[MODEL_KOOPA_SHELL]) {
+                    obj_mark_for_deletion(obj);
+                    break;
+                }
+                obj = (struct Object *) obj->header.next;
+            }
+
+            if ((m->action & ACT_GROUP_MASK) == ACT_GROUP_SUBMERGED) {
+                spawn_object_relative(0, 0, 100, 100, gCurrentObject, MODEL_KOOPA_SHELL,
+                                      bhvKoopaShellUnderwater);
+                break;
+            } else {
+                spawn_object_relative(0, 0, 100, 100, gCurrentObject, MODEL_KOOPA_SHELL, bhvKoopaShell);
+                break;
+            }
+        }
+
+        /* GetBobomb cheat */
+        while (Cheats.GetBob == true && m->controller->buttonDown & L_TRIG
+               && m->controller->buttonPressed & B_BUTTON) {
+            spawn_object_relative(0, 0, 100, 100, gCurrentObject, MODEL_BLACK_BOBOMB, bhvBobomb);
+            break;
+        }
+
+        /* SpawnCommon0 aka Spamba cheat*/
+        switch (Cheats.Spamba) {
+            case 0:
+                break;
+            case 1:
+                if (m->controller->buttonDown & L_TRIG && m->controller->buttonPressed & Z_TRIG) {
+                    spawn_object_relative(0, 0, 100, 100, gCurrentObject, MODEL_AMP, bhvHomingAmp);
+                    break;
+                }
+                break;
+            case 2:
+                if (m->controller->buttonDown & L_TRIG && m->controller->buttonPressed & Z_TRIG) {
+                    spawn_object_relative(0, 0, 0, 150, gCurrentObject, MODEL_BLUE_COIN_SWITCH,
+                                          bhvBlueCoinSwitch);
+                    break;
+                }
+                break;
+            case 3:
+                if (m->controller->buttonDown & L_TRIG && m->controller->buttonPressed & Z_TRIG) {
+                    spawn_object_relative(0, 0, 300, 300, gCurrentObject, MODEL_BOWLING_BALL,
+                                          bhvPitBowlingBall);
+                    break;
+                }
+                break;
+            case 4:
+                if (m->controller->buttonDown & L_TRIG && m->controller->buttonPressed & Z_TRIG) {
+                    spawn_object_relative(0, 0, 0, 200, gCurrentObject, MODEL_BREAKABLE_BOX,
+                                          bhvBreakableBox);
+                    break;
+                }
+                break;
+            case 5:
+                if (m->controller->buttonDown & L_TRIG && m->controller->buttonPressed & Z_TRIG) {
+                    spawn_object_relative(0, 0, 50, 100, gCurrentObject, MODEL_BREAKABLE_BOX_SMALL,
+                                          bhvBreakableBoxSmall);
+                    break;
+                }
+                break;
+            case 6:
+                if (m->controller->buttonDown & L_TRIG && m->controller->buttonPressed & Z_TRIG) {
+                    spawn_object_relative(0, 0, 10, 300, gCurrentObject, MODEL_BREAKABLE_BOX_SMALL,
+                                          bhvJumpingBox);
+                    break;
+                }
+                break;
+            case 7:
+                if (m->controller->buttonDown & L_TRIG && m->controller->buttonPressed & Z_TRIG) {
+                    spawn_object_relative(0, 0, -10, 100, gCurrentObject, MODEL_CHECKERBOARD_PLATFORM,
+                                          bhvCheckerboardPlatformSub);
+                    break;
+                }
+                break;
+            case 8:
+                if (m->controller->buttonDown & L_TRIG && m->controller->buttonPressed & Z_TRIG) {
+                    spawn_object_relative(0, 0, 100, 100, gCurrentObject, MODEL_CHUCKYA, bhvChuckya);
+                    break;
+                }
+                break;
+            case 9:
+                if (m->controller->buttonDown & L_TRIG && m->controller->buttonPressed & Z_TRIG) {
+                    spawn_object_relative(0, 0, 100, 100, gCurrentObject, MODEL_FLYGUY, bhvFlyGuy);
+                    break;
+                }
+                break;
+            case 10:
+                if (m->controller->buttonDown & L_TRIG && m->controller->buttonPressed & Z_TRIG) {
+                    spawn_object_relative(0, 0, 100, 100, gCurrentObject, MODEL_NONE,
+                                          bhvGoombaTripletSpawner);
+                    break;
+                }
+                break;
+            case 11:
+                if (m->controller->buttonDown & L_TRIG && m->controller->buttonPressed & Z_TRIG) {
+                    spawn_object_relative(0, 0, 100, 100, gCurrentObject, MODEL_HEART,
+                                          bhvRecoveryHeart);
+                    break;
+                }
+                break;
+            case 12:
+                if (m->controller->buttonDown & L_TRIG && m->controller->buttonPressed & Z_TRIG) {
+                    spawn_object_relative(0, 0, 0, 200, gCurrentObject, MODEL_METAL_BOX,
+                                          bhvPushableMetalBox);
+                    break;
+                }
+                break;
+            case 13:
+                if (m->controller->buttonDown & L_TRIG && m->controller->buttonPressed & Z_TRIG) {
+                    spawn_object_relative(0, 0, 50, 50, gCurrentObject, MODEL_PURPLE_SWITCH,
+                                          bhvPurpleSwitchHiddenBoxes);
+                    break;
+                }
+                break;
+        }
+
+        /*Jukebox*/
+        if (Cheats.JBC) {
+            /*JBC is the bool, acting like the on/off*/
+            switch(Cheats.JB) {
+                case 0:
+                    play_cap_music(SEQ_EVENT_CUTSCENE_INTRO);
+                    Cheats.JBC = false;
+                    break;
+                case 1:
+                    play_cap_music(SEQ_LEVEL_GRASS);
+                    Cheats.JBC = false;
+                    break;
+                case 2:
+                    play_cap_music(SEQ_LEVEL_INSIDE_CASTLE);
+                    Cheats.JBC = false;
+                    break;
+                case 3:
+                    play_cap_music(SEQ_LEVEL_WATER);
+                    Cheats.JBC = false;
+                    break;
+                case 4:
+                    play_cap_music(SEQ_LEVEL_HOT);
+                    Cheats.JBC = false;
+                    break;
+                case 5:
+                    play_cap_music(SEQ_LEVEL_BOSS_KOOPA);
+                    Cheats.JBC = false;
+                    break;
+                case 6:
+                    play_cap_music(SEQ_LEVEL_SNOW);
+                    Cheats.JBC = false;
+                    break;
+                case 7:
+                    play_cap_music(SEQ_LEVEL_SLIDE);
+                    Cheats.JBC = false;
+                    break;
+                case 8:
+                    play_cap_music(SEQ_LEVEL_SPOOKY);
+                    Cheats.JBC = false;
+                    break;
+                case 9:
+                    play_cap_music(SEQ_LEVEL_UNDERGROUND);
+                    Cheats.JBC = false;
+                    break;
+                case 10:
+                    play_cap_music(SEQ_LEVEL_KOOPA_ROAD);
+                    Cheats.JBC = false;
+                    break;
+                case 11:
+                    play_cap_music(SEQ_LEVEL_BOSS_KOOPA_FINAL);
+                    Cheats.JBC = false;
+                    break;
+                case 12:
+                    play_cap_music(SEQ_MENU_TITLE_SCREEN);
+                    Cheats.JBC = false;
+                    break;
+                case 13:
+                    play_cap_music(SEQ_MENU_FILE_SELECT);
+                    Cheats.JBC = false;
+                    break;
+                case 14:
+                    play_cap_music(SEQ_EVENT_POWERUP);
+                    Cheats.JBC = false;
+                    break;
+                case 15:
+                    play_cap_music(SEQ_EVENT_METAL_CAP);
+                    Cheats.JBC = false;
+                    break;
+                case 16:
+                    play_cap_music(SEQ_EVENT_BOSS);
+                    Cheats.JBC = false;
+                    break;
+                case 17:
+                    play_cap_music(SEQ_EVENT_MERRY_GO_ROUND);
+                    Cheats.JBC = false;
+                    break;
+                case 18:
+                    play_cap_music(SEQ_EVENT_CUTSCENE_CREDITS);
+                    Cheats.JBC = false;
+                    break;
+            }
+        }
+        break;
+    }
+}
\ No newline at end of file
diff --git a/src/game/mario_cheats.h b/src/game/mario_cheats.h
new file mode 100644
index 0000000..73bc652
--- /dev/null
+++ b/src/game/mario_cheats.h
@@ -0,0 +1,42 @@
+#ifndef MARIO_CHEATS_H
+#define MARIO_CHEATS_H
+
+#include <PR/ultratypes.h>
+
+#include "macros.h"
+#include "model_ids.h"
+#include "types.h"
+
+#if defined(MODEL_PLAYER) && defined(MODEL_LUIGIS_CAP)
+#define R96
+#endif
+
+void cheats_set_model(struct MarioState *m);
+void cheats_swimming_speed(struct MarioState *m);
+void cheats_air_step(struct MarioState *m);
+void cheats_long_jump(struct MarioState *m);
+void cheats_mario_inputs(struct MarioState *m);
+
+/* Options */
+#define TIME_BUTTON 0x0080
+
+#include "data/dynos.c.h"
+#define __chaos_mode__   dynos_opt_get_value("chaos_mode")
+#define __time_button__ dynos_opt_get_value("time_button")
+#define __spl__ dynos_opt_get_value("spl")
+#define __no_heavy__ dynos_opt_get_value("no_heavy")
+#define __haz_walk__ dynos_opt_get_value("haz_walk")
+#define __swim_any__ dynos_opt_get_value("swim_any")
+#define __coin_mag__ dynos_opt_get_value("coin_mag")
+#define __wat_con__ dynos_opt_get_value("wat_con")
+#define __wat_lev__ dynos_opt_get_value("wat_lev")
+#define CHAOS_MODE (__chaos_mode__ == 1)
+#define SPL (__spl__)
+#define NO_HEAVY (__no_heavy__ == 1)
+#define HAZ_WALK (__haz_walk__ == 1)
+#define SWIM_ANY (__swim_any__ == 1)
+#define COIN_MAG (__coin_mag__ == 1)
+#define WAT_CON (__wat_con__ == 1)
+#define WAT_LEV (__wat_lev__)
+
+#endif // MARIO_CHEATS_H
diff --git a/src/game/mario_misc.c b/src/game/mario_misc.c
index e6354e8..bc5a982 100644
--- a/src/game/mario_misc.c
+++ b/src/game/mario_misc.c
@@ -2,4 +2,5 @@
 
 #include "sm64.h"
+#include "pc/cheats.h"
 #include "area.h"
 #include "audio/external.h"
@@ -233,5 +234,9 @@ void bhv_unlock_door_star_init(void) {
     gCurrentObject->oUnlockDoorStarYawVel = 0x1000;
     gCurrentObject->oPosX += 30.0f * sins(gMarioState->faceAngle[1] - 0x4000);
-    gCurrentObject->oPosY += 160.0f;
+    if (Cheats.EnableCheats && Cheats.PAC > 0) {
+        gCurrentObject->oPosY += 120.0f;
+    } else {
+        gCurrentObject->oPosY += 160.0f;
+    }
     gCurrentObject->oPosZ += 30.0f * coss(gMarioState->faceAngle[1] - 0x4000);
     gCurrentObject->oMoveAngleYaw = 0x7800;
diff --git a/src/game/mario_step.c b/src/game/mario_step.c
index ba8315c..48ee196 100644
--- a/src/game/mario_step.c
+++ b/src/game/mario_step.c
@@ -2,7 +2,9 @@
 
 #include "sm64.h"
+#include "pc/cheats.h"
 #include "engine/math_util.h"
 #include "engine/surface_collision.h"
 #include "mario.h"
+#include "mario_cheats.h"
 #include "audio/external.h"
 #include "game_init.h"
@@ -106,4 +108,7 @@ void mario_bonk_reflection(struct MarioState *m, u32 negateSpeed) {
 
 u32 mario_update_quicksand(struct MarioState *m, f32 sinkingSpeed) {
+    if (Cheats.EnableCheats && HAZ_WALK == 1) {
+        m->quicksandDepth = 0.0f;
+    } else
     if (m->action & ACT_FLAG_RIDING_SHELL) {
         m->quicksandDepth = 0.0f;
diff --git a/src/game/options_menu.c b/src/game/options_menu.c
index 56ebdeb..8cfef93 100644
--- a/src/game/options_menu.c
+++ b/src/game/options_menu.c
@@ -15,4 +15,5 @@
 #include "game/mario_misc.h"
 #include "game/game_init.h"
+#include "game/cheats_menu.h"
 #include "game/ingame_menu.h"
 #include "game/options_menu.h"
@@ -219,4 +220,31 @@ static void optvideo_apply(UNUSED struct Option *self, s32 arg) {
 }
 
+
+static void setCap_Wing(UNUSED struct Option *self, s32 arg) {
+    if (!arg) Cheats.WingCap = true;
+}
+static void setCap_Metal(UNUSED struct Option *self, s32 arg) {
+    if (!arg) Cheats.MetalCap = true;
+}
+static void setCap_Vanish(UNUSED struct Option *self, s32 arg) {
+    if (!arg) Cheats.VanishCap = true;
+}
+static void setCap_Remove(UNUSED struct Option *self, s32 arg) {
+    if (!arg) Cheats.RemoveCap = true;
+}
+static void setCap_Normal(UNUSED struct Option *self, s32 arg) {
+    Cheats.WingCap = false;
+    Cheats.MetalCap = false;
+    Cheats.VanishCap = false;
+    Cheats.RemoveCap = false;
+    if (!arg) Cheats.NormalCap = true;
+}
+static void setJBC(UNUSED struct Option *self, s32 arg) {
+    if (!arg)
+        Cheats.JBC = true;
+}
+
+
+
 /* submenu option lists */
 
@@ -274,13 +302,43 @@ static struct Option optsAudio[] = {
 
 static struct Option optsCheats[] = {
-    DEF_OPT_TOGGLE( optsCheatsStr[0], &Cheats.EnableCheats ),
-    DEF_OPT_TOGGLE( optsCheatsStr[1], &Cheats.MoonJump ),
-    DEF_OPT_TOGGLE( optsCheatsStr[2], &Cheats.GodMode ),
-    DEF_OPT_TOGGLE( optsCheatsStr[3], &Cheats.InfiniteLives ),
-    DEF_OPT_TOGGLE( optsCheatsStr[4], &Cheats.SuperSpeed ),
-    DEF_OPT_TOGGLE( optsCheatsStr[5], &Cheats.Responsive ),
-    DEF_OPT_TOGGLE( optsCheatsStr[6], &Cheats.ExitAnywhere ),
-    DEF_OPT_TOGGLE( optsCheatsStr[7], &Cheats.HugeMario ),
-    DEF_OPT_TOGGLE( optsCheatsStr[8], &Cheats.TinyMario ),
+    DEF_OPT_TOGGLE(optsCheatsStr[0], &Cheats.EnableCheats),
+    DEF_OPT_TOGGLE(optsCheatsStr[1], &Cheats.MoonJump),
+    DEF_OPT_TOGGLE(optsCheatsStr[2], &Cheats.GodMode),
+    DEF_OPT_TOGGLE(optsCheatsStr[3], &Cheats.InfiniteLives),
+    DEF_OPT_TOGGLE(optsCheatsStr[4], &Cheats.SuperSpeed),
+    DEF_OPT_TOGGLE(optsCheatsStr[5], &Cheats.Responsive),
+    DEF_OPT_TOGGLE(optsCheatsStr[6], &Cheats.ExitAnywhere),
+    DEF_OPT_TOGGLE(optsCheatsStr[7], &Cheats.HugeMario),
+    DEF_OPT_TOGGLE(optsCheatsStr[8], &Cheats.TinyMario),
+    DEF_OPT_CHOICE(optsCheatsStr2[0], &Cheats.Coin, CoinChoices),
+    DEF_OPT_TOGGLE(optsCheatsStr2[1], &Cheats.Hover),
+    DEF_OPT_TOGGLE(optsCheatsStr2[2], &Cheats.Moon),
+    DEF_OPT_CHOICE(optsCheatsStr2[3], &Cheats.Run, SpeedChoices),
+    DEF_OPT_TOGGLE(optsCheatsStr2[4], &Cheats.NDB),
+    DEF_OPT_TOGGLE(optsCheatsStr2[5], &Cheats.Jump),
+    DEF_OPT_TOGGLE(optsCheatsStr2[6], &Cheats.SPD),
+    DEF_OPT_TOGGLE(optsCheatsStr2[7], &Cheats.TPF),
+    DEF_OPT_CHOICE(optsCheatsStr2[8], &Cheats.JB, SeqChoices),
+    DEF_OPT_BUTTON(optsCheatsStr2[9], setJBC),
+    DEF_OPT_TOGGLE(optsCheatsStr2[10], &Cheats.QuikEnd),
+    DEF_OPT_CHOICE(optsCheatsStr2[11], &Cheats.Hurt, HurtCheatChoices),
+    DEF_OPT_TOGGLE(optsCheatsStr2[12], &Cheats.Cann),
+    DEF_OPT_TOGGLE(optsCheatsStr2[13], &Cheats.AutoWK),
+    DEF_OPT_TOGGLE(optsCheatsStr2[14], &Cheats.GetShell),
+    DEF_OPT_TOGGLE(optsCheatsStr2[15], &Cheats.GetBob),
+    DEF_OPT_CHOICE(optsCheatsStr2[16], &Cheats.Spamba, SpamCheatChoices),
+    DEF_OPT_TOGGLE(optsCheatsStr2[17], &Cheats.Swim),
+    DEF_OPT_BUTTON(optsCheatsStr2[18], setCap_Wing),
+    DEF_OPT_BUTTON(optsCheatsStr2[19], setCap_Metal),
+    DEF_OPT_BUTTON(optsCheatsStr2[20], setCap_Vanish),
+    DEF_OPT_BUTTON(optsCheatsStr2[21], setCap_Remove),
+    DEF_OPT_BUTTON(optsCheatsStr2[22], setCap_Normal),
+    DEF_OPT_CHOICE(optsCheatsStr2[23], &Cheats.BLJAnywhere, bljCheatChoices),
+    DEF_OPT_CHOICE(optsCheatsStr2[24], &Cheats.PAC, PlayAsCheatChoices),
+    DEF_OPT_TOGGLE(optsCheatsStr2[25], &Cheats.Triple),
+    DEF_OPT_TOGGLE(optsCheatsStr2[26], &Cheats.Fly),
+    DEF_OPT_TOGGLE(optsCheatsStr2[27], &Cheats.NoBounds),
+    DEF_OPT_TOGGLE(optsCheatsStr2[28], &Cheats.FLJ),
+    DEF_OPT_TOGGLE(optsCheatsStr2[29], &Cheats.TimeStop),
 
 };
diff --git a/src/pc/cheats.h b/src/pc/cheats.h
index eaf71ab..42c1343 100644
--- a/src/pc/cheats.h
+++ b/src/pc/cheats.h
@@ -14,4 +14,35 @@ struct CheatList {
     bool         HugeMario;
     bool         TinyMario;
+    unsigned int Coin;
+    bool         Hover;
+    bool         Moon;
+    unsigned int Run;
+    bool         NDB;
+    bool         Jump;
+    bool         SPD;
+    bool         TPF;
+    unsigned int JB;
+    bool         JBC;
+    bool         QuikEnd;
+    unsigned int Hurt;
+    bool         Cann;
+    bool         AutoWK;
+    bool         GetShell;
+    bool         GetBob;
+    unsigned int Spamba;
+    bool         Swim;
+    bool         WingCap;
+    bool         MetalCap;
+    bool         VanishCap;
+    bool         RemoveCap;
+    bool         NormalCap;
+    unsigned int BLJAnywhere;
+    unsigned int PAC;
+    bool         Triple;
+    bool         Fly;
+    bool         NoBounds;
+    bool         FLJ;
+    bool         TimeStop;
+    bool         TimeSlow;
 };
 
diff --git a/src/pc/configfile.c b/src/pc/configfile.c
index 7411d4f..6bc0bd0 100644
--- a/src/pc/configfile.c
+++ b/src/pc/configfile.c
@@ -8,4 +8,5 @@
 
 #include "platform.h"
+#include "cheats.h"
 #include "configfile.h"
 #include "cliopts.h"
@@ -125,4 +126,29 @@ static const struct ConfigOption options[] = {
     #ifdef EXTERNAL_DATA
     {.name = "precache",             .type = CONFIG_TYPE_BOOL, .boolValue = &configPrecacheRes},
+    {.name = "enable_cheats", .type = CONFIG_TYPE_BOOL, .boolValue = &Cheats.EnableCheats },
+    {.name = "moonjump", .type = CONFIG_TYPE_BOOL, .boolValue = &Cheats.MoonJump },
+    {.name = "invincible", .type = CONFIG_TYPE_BOOL, .boolValue = &Cheats.GodMode },
+    {.name = "infintie_lives", .type = CONFIG_TYPE_BOOL, .boolValue = &Cheats.InfiniteLives },
+    {.name = "super_speed", .type = CONFIG_TYPE_BOOL, .boolValue = &Cheats.SuperSpeed },
+    {.name = "controls", .type = CONFIG_TYPE_BOOL, .boolValue = &Cheats.Responsive },
+    {.name = "exit_anywhere", .type = CONFIG_TYPE_BOOL, .boolValue = &Cheats.ExitAnywhere },
+    {.name = "huge_mario", .type = CONFIG_TYPE_BOOL, .boolValue = &Cheats.HugeMario },
+    {.name = "tiny_mario", .type = CONFIG_TYPE_BOOL, .boolValue = &Cheats.TinyMario },
+    {.name = "coin", .type = CONFIG_TYPE_UINT, .uintValue = &Cheats.Coin },
+    {.name = "hover_mode", .type = CONFIG_TYPE_BOOL, .boolValue = &Cheats.Hover },
+    {.name = "moon_gravity", .type = CONFIG_TYPE_BOOL, .boolValue = &Cheats.Moon },
+    {.name = "run_speed", .type = CONFIG_TYPE_UINT, .uintValue = &Cheats.Run },
+    {.name = "no_death_barrier", .type = CONFIG_TYPE_BOOL, .boolValue = &Cheats.NDB },
+    {.name = "jumps_higher", .type = CONFIG_TYPE_BOOL, .boolValue = &Cheats.Jump },
+    {.name = "speed_display", .type = CONFIG_TYPE_BOOL, .boolValue = &Cheats.SPD },
+    {.name = "t_pose_float", .type = CONFIG_TYPE_BOOL, .boolValue = &Cheats.TPF },
+    {.name = "cannon_anywhere", .type = CONFIG_TYPE_BOOL, .boolValue = &Cheats.Cann },
+    {.name = "auto_wk", .type = CONFIG_TYPE_BOOL, .boolValue = &Cheats.AutoWK },
+    {.name = "get_shell", .type = CONFIG_TYPE_BOOL, .boolValue = &Cheats.GetShell },
+    {.name = "get_bobomb", .type = CONFIG_TYPE_BOOL, .boolValue = &Cheats.GetBob },
+    {.name = "swift_swim", .type = CONFIG_TYPE_BOOL, .boolValue = &Cheats.Swim },
+    {.name = "blj_anywhere", .type = CONFIG_TYPE_UINT, .uintValue = &Cheats.BLJAnywhere },
+    {.name = "play_as", .type = CONFIG_TYPE_UINT, .uintValue = &Cheats.PAC },
+    {.name = "flyer", .type = CONFIG_TYPE_BOOL, .boolValue = &Cheats.Fly },
     #endif
     #ifdef BETTERCAMERA
